[{"content":"概述 在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式问题，读取文件是否存在，网络是否始终保持通畅等等。\n异常 ：指的是程序在执行过程中，出现的非正常情况。如果不处理异常最终会导致 JVM 的非正常停止。\n异常指的并不是语法错误和逻辑错误。\n语法错误，编译不会通过，更不会产生字节码文件，程序根本就不能运行。\n代码逻辑错误，只是没有得到想要的结果，例如：求 a 与 b 的和，你写成了 a - b\n异常的抛出机制 Java 中把不同的异常用不同的类表示，一旦发生某种异常，就创建该异常类型的对象，并且抛出（throw）。然后程序员可以捕获 （catch）到这个异常对象并处理；如果没有捕获（catch）这个异常对象，那么这个异常对象将会导致程序终止。\n运行下面的程序，程序会产生一个数组角标越界异常 ArrayIndexOfBoundsException 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ArrayTools { // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) { int element = arr[index]; return element; } } class ExceptionDemo { public static void main(String[] args) { int[] arr = { 34, 12, 67 }; intnum = ArrayTools.getElement(arr, 4) System.out.println(\u0026#34;num = \u0026#34; + num); System.out.println(\u0026#34; over\u0026#34;); } } 上述程序执行过程图解：\n如何对待异常 对于程序出现的异常，一般有两种解决方法：\n一是遇到错误就终止程序的运行。\n另一种方法是程序员在编写程序时，就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、以及异常的处理，保证代码的健壮性。\nJava 的异常体系 Throwable java.lang.Throwable 类是Java程序执行过程中发生的异常事件对应的类的根父类。\nThrowable中的常用方法：\npublic String getMessage() ：获取发生异常的原因。\npublic void printStackTrace() ：打印异常的详细信息。\n包含了异常的类型、异常的原因、异常出现的位置，由于 printStackTrace 打印的信息中已经包括了 getMessage 中的信息，所以在开发和调试阶段都较推荐使用 printStackTrace 。\nError 和 Exception Throwable 可分为两大类：Error 和 Exception 。分别对应着 java.lang.Error 与 java.lang.Exception 两个类。\nError: JVM 无法解决的严重问题。如：JVM 系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。例如：\nStackOverflowError（栈内存溢出） OutOfMemoryError（堆内存溢出，简称OOM）。 Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行。否则一旦发生异常，程序就会终止。例如：\n空指针访问 试图读取不存在的文件 网络连接中断 数组角标越界 1 2 3 4 5 6 public class Test3 { public static void main(String[] args) { int[] array = new int[10]; System.out.println(array[10]); } } 编译时异常和运行时异常 Java 程序的执行分为编译时过程和运行时过程。有的错误只有在运行时才会发生，比如：除数为0，数组下标越界等。\n因此，根据异常可能出现的阶段，可以将异常分为：\n编译时期异常（即 checked 异常、受检异常）：在代码编译阶段，编译器就能明确 警示 当前代码可能发生（不是一定发生）某个异常，并 明确督促 程序员提前编写处理它的代码。如果程序员没有编写对应的异常处理代码，则编译器就会直接判定编译失败，从而不能生成字节码文件。通常，这类异常的发生不是由程序员的代码引起的，或者不是靠加简单判断就可以避免的，例如：FileNotFoundException（文件找不到异常）、IOException（输入输出异常）、ClassNotFoundException（类找不到异常）。 运行时期异常（即 runtime 异常、unchecked 异常、非受检异常）：在代码编译阶段，编译器完全不做任何检查，无论该异常是否会发生，编译器都不给出任何提示。只有等代码运行起来并确实发生了某个异常，它才能被发现。通常，这类异常是由程序员的代码编写不当引起的，只要稍加判断，或者细心检查就可以避免。 java.lang.RuntimeException 类及它的子类都是运行时异常。比如：ArrayIndexOutOfBoundsException 数组下标越界异常， ClassCastException 类型转换异常、NullPointerException 空指针异常。\n常见错误和异常 Error 最常见的就是 VirtualMachineError ，它有两个经典的子类：StackOverflowError、OutOfMemoryError。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // StackOverflowError public class StackOverflowErrorTest { public static void main(String[] args) { main(args); // 无限递归 main 方法 } } // OutOfMemoryError public class OutOfMemoryErrorTest { public static void main(String[] args) { while (true) { long[] longs = new long[1024 * 1024 * 1024]; // 每一次都申请了 8G 内存 } } } Exception 编译时异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import org.junit.Test; import java.io.File; import java.io.FileInputStream; public class CheckedExceptionTest { @Test public void test1() { Class loadClass = Class.forName(\u0026#34;java.lang.Exception\u0026#34;); // ClassNotFoundException } public void test2() { File file = new File(\u0026#34;D:\\\\Java从入门到提桶跑路.txt\u0026#34;); FileInputStream fis = new FileInputStream(file); // FileNotFoundException int input = fis.read(); // IOException while (input != -1) { System.out.print((char) input); input = fis.read(); // IOException } fis.close(); // IOException } } 运行时异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import org.junit.Test; import java.util.Scanner; public class RuntimeExceptionTest { @Test public void test1(){ int[][] arr = new int[3][]; System.out.println(arr[0].length); // NullPointerException } @Test public void test2(){ Object obj = 15; // 这里执行了自动装箱 String str = (String) obj; // ClassCastException } @Test public void test3(){ int[] arr = new int[5]; for (int i = 1; i \u0026lt;= 5; i++) { System.out.println(arr[i]); // ArrayIndexOutOfBoundsException } } @Test public void test4(){ Scanner input = new Scanner(System.in); System.out.print(\u0026#34;请输入一个整数：\u0026#34;); int num = input.nextInt(); // 这里输入了一个非整数 InputMismatchException input.close(); } @Test public void test5(){ int a = 1; int b = 0; System.out.println(a / b); // ArithmeticException } } 异常的处理 概述 在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行 x / y 运算时，要检测用户输入的是数值还是字符、数据是否为空、分母是否为 0 等。过多的 if-else 分支会导致程序的代码加长、臃肿，可读性差，程序员需要花很大的精力 “堵漏洞” 。因此采用异常处理机制来简化操作。\nJava 采用的异常处理机制，是将需要异常处理的程序代码集中在一起 ，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。\nJava 异常处理有两种方式：\ntry-catch-finally throws + 异常类型 捕获异常（try-catch-finally） Java 提供了异常处理的抓抛模型：\nJava 程序的执行过程中如果出现异常就会生成一个异常类对象，该异常对象将被提交给 Java 运行时系统，这个过程称为抛出（throw）异常。 如果一个方法内抛出异常，该异常对象会被抛给方法调用者来处理。如果异常没有被调用者处理，则异常会继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获（catch）异常。如果一个异常回到 main() 方法，并且 main() 也不处理，则程序会终止运行。 1 2 3 4 5 6 7 8 9 10 11 12 try { ......\t// 可能产生异常的代码 } catch( 异常类型1 e ) { ......\t// 当产生异常类型1异常时的处置措施 } catch( 异常类型2 e ) { ...... // 当产生异常类型2异常时的处置措施 } finally { ...... // 无论是否发生异常，都无条件执行的语句 } try - catch 模型 当某段代码可能发生异常，不管这个异常是编译时异常（受检异常）还是运行时异常（非受检异常），我们都可以使用 try 块将它包围起来，并在 try 块下面编写 catch 分支尝试捕获对应的异常对象。\n捕获异常的第一步是用 try{ … }语句块 选定捕获异常的范围，将可能出现异常的业务逻辑代码放在 try 语句块中。\ncatch 分支分为两个部分，catch() 中编写异常类型和异常参数名，{} 中编写如果发生了这个异常要怎么做的处理代码。\n每个 try 语句块可以伴随一个或多个 catch 语句，用于处理可能产生的不同类型的异常对象。\n如果明确知道产生的是何种异常，可以用该异常类作为 catch 的参数类型，也可以用其父类作为 catch 的参数类型。\n比如：可以用 ArithmeticException 类作为参数的地方，就可以用 RuntimeException 类作为参数，或者用所有异常的父类Exception 类作为参数。但不能是与 ArithmeticException 类无关的异常类型，如 NullPointerException 或自定义的ArithmeticException 的子类，如果是的话 catch 中的语句将不会执行。 如果有多个 catch 分支，并且多个异常类型有父子类关系，必须保证小的子异常类型在上，大的父异常类型在下，否则会编译失败。\ncatch 中常用异常处理的方式：① public String getMessage() ② public void printStackTrace()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public void test() { try { String str = \u0026#34;Hello Java Exception\u0026#34;; str = null; System.out.println(str.charAt(0)); } catch (NullPointerException e) { // 异常的处理方式1 System.out.println(\u0026#34;出现了空指针异常\u0026#34;); } catch (ClassCastException e) { // 异常的处理方式2 System.out.println(\u0026#34;出现了类型转换的异常\u0026#34;); } catch (RuntimeException e) { // 因为运行时异常是上面两个异常的父类 所以要排在它们后面 // 异常的处理方式3 System.out.println(\u0026#34;出现了运行时异常\u0026#34;); } // 此处的代码，在异常被处理了以后，是可以正常执行的 System.out.println(\u0026#34;hello\u0026#34;); } 如果在程序运行时，try 块中的代码没有发生异常，那么 catch 所有的分支都不执行。\n如果在程序运行时，try 块中的代码发生了异常，根据异常对象的类型，将从上到下选择第一个匹配的 catch 分支执行。此时 try 中发生异常的语句下面的代码将不执行，而整个 try\u0026hellip;catch 之后的代码可以继续运行。\n如果在程序运行时，try 块中的代码发生了异常，但是所有 catch 分支都无法匹配（捕获）这个异常，那么 JVM 将会终止当前方法的执行，并把异常对象“抛”给调用者。如果调用者不进行处理，程序就会终止运行。\nfinally 的使用 因为异常会引发程序跳转，从而会导致有些语句执行不到。而程序中有一些特定的代码无论异常是否发生都一定需要执行。例如，数据库连接、输入流输出流、Socket 连接、Lock 锁的关闭等，这样的代码通常就会放到 finally 块中。所以，我们通常将一定要被执行的代码写在 finally 中。\n不论在 try 代码块中是否发生了异常、try 代码块中是否有 return、catch 语句是否执行、catch 中语句是否有异常、catch 语句中是否有 return，finally块中的代码都会被执行。唯一的例外就是使用 System.exit() 来强制终止当前正在运行的 Java 虚拟机，这样的话 finally 中的代码就没有机会执行了。\nfinally 语句和 catch 语句是可选的，不一定要跟在 try 的背后。\n1 2 3 4 5 6 7 8 9 10 11 public void test() { try {} catch (Exception e) {} finally {} try {} catch (Exception e) {} try {} finally {} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 // finally 的使用 // 1.确保资源被关闭 import org.junit.Test; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.util.InputMismatchException; import java.util.Scanner; public class FinallyTest1 { @Test public void test1() { Scanner input = new Scanner(System.in); try { System.out.print(\u0026#34;请输入第一个整数：\u0026#34;); int a = input.nextInt(); System.out.print(\u0026#34;请输入第二个整数：\u0026#34;); int b = input.nextInt(); int result = a / b; System.out.println(a + \u0026#34; / \u0026#34; + b + \u0026#34; = \u0026#34; + result); } catch (InputMismatchException e) { System.out.println(\u0026#34;数字格式不正确，请输入两个整数\u0026#34;); } catch (ArithmeticException e) { System.out.println(\u0026#34;第二个整数不能为0\u0026#34;); } finally { System.out.println(\u0026#34;程序结束，释放资源\u0026#34;); input.close(); } } @Test public void test2() { FileInputStream fis = null; try { File file = new File(\u0026#34;D:\\\\Java从入门到提桶跑路.txt\u0026#34;); fis = new FileInputStream(file); // FileNotFoundException int b = fis.read(); // IOException while (b != -1) { System.out.print((char) b); b = fis.read(); //IOException } } catch (IOException e) { e.printStackTrace(); } finally { try { if (fis != null) fis.close(); // IOException } catch (IOException e) { e.printStackTrace(); } } } } // 2.在 try 中返回 class FinallyTest2 { public static void main(String[] args) { int result = test(\u0026#34;12\u0026#34;); System.out.println(result); /* console: test结束 1 */ } public static int test(String str) { try { Integer.parseInt(str); return 1; } catch (NumberFormatException e) { return -1; } finally { System.out.println(\u0026#34;test结束\u0026#34;); } } } // 3.在 catch 中返回 class FinallyTest3 { public static void main(String[] args) { int result = test(\u0026#34;a\u0026#34;); System.out.println(result); /* console: test结束 -1 */ } public static int test(String str) { try { Integer.parseInt(str); return 1; } catch (NumberFormatException e) { return -1; } finally { System.out.println(\u0026#34;test结束\u0026#34;); } } } // 4.在 finally 中返回 class FinallyTest4 { public static void main(String[] args) { int result = test(\u0026#34;a\u0026#34;); System.out.println(result); /* console: test结束 0 */ } public static int test(String str) { try { Integer.parseInt(str); return 1; } catch (NumberFormatException e) { return -1; } finally { System.out.println(\u0026#34;test结束\u0026#34;); return 0; } } } 如何对待编译期异常和运行时异常 编译期异常：\n如果抛出的异常是 IOException 等编译时异常就必须要捕获，否则就会导致编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常。\n1 2 3 4 5 6 7 8 9 10 11 public class Test { public static void main(String[] args) { try { Class loadClass = Class.forName(\u0026#34;java.lang.Object\u0026#34;); } catch (ClassNotFoundException e) { // throw new RuntimeException(\u0026#34;ClassNotFoundException\u0026#34;); OK 将编译时异常转化为运行时异常 e.printStackTrace(); // OK 直接处理异常 } } } 运行时异常：\n运行时异常的特点是：即使没有使用 try 和 catch 捕获，编译也可以通过（但运行时会发生异常使得程序运行终止）。所以对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。\n声明抛出异常类型（throws） 如果在编写方法体的代码时，某句代码可能发生某个编译时异常，此时不处理这个异常编译不能通过，但是在当前方法体中可能不适合处理或无法给出合理的处理方式，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。\nthrows的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 [修饰符] \u0026lt;返回值类型\u0026gt; \u0026lt;方法名(形参列表)\u0026gt; throws 异常类型1, 异常类型2 ... { // ... } // 抛出编译时异常 public class ThrowsCheckedExceptionTest { public static void main(String[] args) { System.out.println(\u0026#34;上课.....\u0026#34;); try { afterClass(); // 换到这里处理异常 } catch (InterruptedException e) { e.printStackTrace(); System.out.println(\u0026#34;准备提前上课\u0026#34;); } System.out.println(\u0026#34;上课.....\u0026#34;); } public static void afterClass() throws InterruptedException { for (int i = 10; i \u0026gt;= 1; i--) { // sleep()有可能会抛出 InterruptedException 这个编译期异常 Thread.sleep(1000); // 本来应该在这里通过 try-catch 来处理异常 System.out.println(\u0026#34;距离上课还有：\u0026#34; + i + \u0026#34;分钟\u0026#34;); } } } // 抛出运行时异常 import java.util.InputMismatchException; import java.util.Scanner; public class ThrowsCheckedExceptionTest { public static void main(String[] args) { Scanner input = new Scanner(System.in); try { System.out.print(\u0026#34;请输入第一个整数：\u0026#34;); int a = input.nextInt(); System.out.print(\u0026#34;请输入第二个整数：\u0026#34;); int b = input.nextInt(); int result = divide(a, b); System.out.println(a + \u0026#34;/\u0026#34; + b + \u0026#34;=\u0026#34; + result); } catch (ArithmeticException | InputMismatchException e) { e.printStackTrace(); } finally { input.close(); } } public static int divide(int a, int b) throws ArithmeticException { return a / b; } } throws 后面也可以跟运行时异常类型，只是运行时异常类型写或不写对于编译器和程序执行来说几乎没有任何区别。如果写了，唯一的区别就是调用者调用该方法后，使用 try\u0026hellip;catch 结构时，IDEA可以获得更多的信息，提示用户需要添加哪种catch分支。 所以虽然写不写无所谓，但我个人还是推荐写一下的。\nthrows 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class ThrowsCheckedExceptionTest { public static void main(String[] args) { try { method(); } catch (RuntimeException e) { e.printStackTrace(); } } public static void method() throws RuntimeException { int i = 10 / 0; // ArithmeticException int[] array = new int[10]; array[100] = 10; // ArrayIndexOutOfBoundsException } } ArithmeticException 和 ArrayIndexOutOfBoundsException 都是 RuntimeException 的子类，所以通过抛出 RuntimeException 来将这两个异常抛出。\n重写方法时对 throws 的要求 方法重写时对于方法签名是有严格要求的：\n方法名必须相同 形参列表必须相同 返回值类型： 基本数据类型和void：必须相同 引用数据类型：相同或者是被重写方法返回值的子类 权限修饰符：必须大于等于被重写方法的权限，并且要求父类中的被重写方法在子类中是可见的（非private） 不能是static，final修饰的方法 附表：\n权限大小：public \u0026gt; protected \u0026gt; default \u0026gt; private\n修饰符 本类内部 本包内 其他包的子类 其他包非子类 private √ × × × 缺省（default） √ √ × × protected √ √ √ × public √ √ √ √ 此外，对于throws异常列表要求：\n如果父类被重写方法的方法签名后面没有 “ throws 编译时异常类型”，那么重写方法时，方法签名后面也不能出现“ throws 编译时异常类型”。 如果父类被重写方法的方法签名后面有 “ throws 编译时异常类型”，那么重写方法时，throws 的编译时异常类型必须是被重写方法 throws 的编译时异常类型或其子类，或者不 throws 编译时异常（如果重写方法中有编译时异常的话，就用 try-catch 处理掉）。 方法重写，对于“ throws 运行时异常类型”没有要求。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.io.IOException; class Father { public void method() throws Exception { System.out.println(\u0026#34;Father.method\u0026#34;); } } class Son extends Father { @Override public void method() throws IOException, ClassCastException { System.out.println(\u0026#34;Son.method\u0026#34;); } } 两种异常处理方式的选择 前提：对异常使用下面相应的处理方式，此时的异常主要指的是编译时异常，比如运行时异常就不需要满足第二条规则。\n如果程序代码中涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用 try-catch-finally 来处理，保证不出现内存泄漏。 如果父类被重写的方法没有 throws 异常类型，而子类重写的方法中出现异常，则只能考虑使用 try-catch-finally 进行处理，不能 throws。 开发中，如果方法 a 中依次调用了方法 b, c, d 等方法，且方法 b, c, d 之间是递进关系（比如 c 的运行依赖 b 的结果，d 的运行依赖于 c 的结果）。此时，如果方法 b, c, d 中有异常，我们通常选择使用 throws ，而方法 a 中通常选择使用 try-catch-finally 。 1 2 3 4 5 6 7 8 9 10 11 // 运行时异常不满足第二条规则 class Father { public void method() {} } class Son extends Father { @Override public void method() throws RuntimeException { throw new RuntimeException(); } } 手动抛出异常对象（throw） Java 中异常对象的生成有两种方式：\n由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，那么针对当前代码，就会在后台自动创建一个对应异常类的实例对象并抛出。如果深究源码就会发现自动生成的异常对象也是 api 开发者手动抛出的对象，只是相对于我们这些 api 使用者来说是自动的而已。 由开发人员手动创建：new 异常类型([实参列表]); 如果创建好的异常对象不抛出（throw）就不会对程序有任何影响，就像创建一个普通对象一样。但是一旦 throw 抛出，就会对程序运行产生影响了。 1 throw new 异常类名([参数列表]); throw 语句抛出的异常对象，和 JVM 自动创建和抛出的异常对象一样：\n如果是编译时异常类型的对象，同样需要使用 throws 或者 try...catch 处理，否则编译不通过。 如果是运行时异常类型的对象，编译器不做约束。 可以抛出的异常必须是 Throwable 或其子类的实例。下面的语句在编译时将会产生语法错误：\n1 throw new String(\u0026#34;want to throw\u0026#34;); 注意点：\n无论是编译时异常类型的对象，还是运行时异常类型的对象，如果没有被 try..catch 合理的处理，都会导致程序崩溃。\nthrow 语句会导致程序执行流程被改变，throw 语句是明确抛出一个异常对象，因此 throw 下面的代码将不会执行。\n如果当前方法没有 try...catch 处理这个抛出的异常对象，throw 语句就会代替 return 语句提前终止当前方法的执行，并返回一个异常对象给调用者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class ThrowTest { public static void main(String[] args) { try { System.out.println(max(4, 2, 31, 1)); } catch (Exception e) { e.printStackTrace(); } try { System.out.println(max(4)); } catch (Exception e) { e.printStackTrace(); } try { System.out.println(max()); } catch (Exception e) { e.printStackTrace(); } } public static int max(int... nums) { if (nums == null || nums.length == 0) { throw new IllegalArgumentException(\u0026#34;没有传入任何整数，无法获取最大值\u0026#34;); } int max = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; max) { max = nums[i]; } } return max; } } 自定义异常 为什么要自定义异常 Java 中不同的异常类，分别表示着某一种具体的异常情况。那么在开发中总是有些异常情况是核心类库中没有定义好的，此时我们需要根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题，某员工已在团队中等。\n如何自定义异常 继承一个异常类型 自定义一个编译时异常类型：自定义类 extends java.lang.Exception。 自定义一个运行时异常类型：自定义类 extends java.lang.RuntimeException。 提供构造器 建议提供至少两个构造器：一个是无参构造，一个是参数列表为（String message）的构造器。 提供 serialVersionUID 这个 uid 是供对象的序列化和反序列化用的 如果还是不清楚如何自定义异常可以参考 JDK 中的 NullPointerException 是如何继承 RuntimeException 的，当然这只是一个例子，你可以参考异常体系中的任意一对继承关系。\n注意事项 自定义的异常只能通过 throw 抛出。抛出后可以由 try-catch 处理，也可以借助 throws 甩锅给调用者。 自定义异常最重要的是异常类的名字和 message 属性。当异常出现时，可以根据名字判断异常类型。比如：TeamException(\u0026quot;成员已满，无法添加\u0026quot;); 、 TeamException(\u0026quot;该员工已是某团队成员\u0026quot;); 所以在自定义异常类和给手动抛出的异常提供 message时一定要做到见名知意，简洁明白。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.io.Serial; class MyException extends Exception { @Serial private static final long serialVersionUID = 114514415411L; public MyException() { } public MyException(String message) { super(message); } } class MyExceptionTest { public void register(int num) throws MyException { if (num \u0026lt; 0) throw new MyException(\u0026#34;人数为负值，不合理\u0026#34;); else System.out.println(\u0026#34;登记人数\u0026#34; + num); } public void manager() { try { register(100); } catch (MyException e) { System.out.print(\u0026#34;登记失败，出错种类\u0026#34;); } System.out.print(\u0026#34;本次登记操作结束\u0026#34;); } public static void main(String[] args) { MyExceptionTest t = new MyExceptionTest(); t.manager(); } } 小结 异常处理5个关键字：\n类比：上游排污，下游治污。\n小哲理：\n世界上最遥远的距离，是我在 if 里你在 else 里，似乎一直相伴又永远分离；\n世界上最痴心的等待，是我当 case 你是 switch，或许永远都选不上自己；\n世界上最真情的相依，是你在 try 我在 catch 。无论你发神马脾气，我都默默承受，静静处理。到那时，再来期待我们的 finally。\n参考引用 尚硅谷Java零基础全套视频教程(宋红康主讲，java入门自学必备) - 异常处理\n","date":"2024-10-20T16:33:04+08:00","image":"https://kotoriforest.us.kg/p/1020-%E6%9E%9A%E4%B8%BE%E7%B1%BB/cover_hu9013448323673794041.png","permalink":"https://kotoriforest.us.kg/p/1020-%E6%9E%9A%E4%B8%BE%E7%B1%BB/","title":"枚举类"},{"content":" 转载自IDEA中快捷键的使用和修改\n通用快捷键 说明 快捷键 复制代码-copy ctrl + c 粘贴-paste ctrl + v 剪切-cut ctrl + x 撤销-undo ctrl + z 反撤销-redo ctrl + shift + z 保存-save all ctrl + s 全选-select all ctrl + a 提高编写速度 说明 快捷键 智能提示-edit alt + enter 提示代码模板-insert live template ctrl+j 使用xx块环绕-surround with \u0026hellip; ctrl+alt+t 调出生成getter/setter/构造器等结构-generate \u0026hellip; alt+insert 自动生成返回值变量-introduce variable \u0026hellip; ctrl+alt+v 复制指定行的代码-duplicate line or selection ctrl+d 删除指定行的代码-delete line ctrl+y 切换到下一行代码空位-start new line shift + enter 切换到上一行代码空位-start new line before current ctrl +alt+ enter 向上移动代码-move statement up ctrl+shift+↑ 向下移动代码-move statement down ctrl+shift+↓ 向上移动一行-move line up alt+shift+↑ 向下移动一行-move line down alt+shift+↓ 方法的形参列表提醒-parameter info ctrl+p 批量修改指定的变量名、方法名、类名等-rename shift+f6 抽取代码重构方法-extract method \u0026hellip; ctrl+alt+m 重写父类的方法-override methods \u0026hellip; ctrl+o 实现接口的方法-implements methods \u0026hellip; ctrl+i 选中的结构的大小写的切换-toggle case ctrl+shift+u 批量导包-optimize imports ctrl+alt+o 类结构、查找、查看源码 说明 快捷键 如何查看源码-go to class\u0026hellip; ctrl + 选中指定的结构 或 ctrl+b 显示当前类结构，支持搜索指定的方法、属性等-file structure ctrl+f12 退回到前一个编辑的页面-back ctrl+alt+← 进入到下一个编辑的页面-forward ctrl+alt+→ 打开的类文件之间切换-select previous/next tab alt+←/→ 光标选中指定的类，查看继承树结构-Type Hierarchy ctrl+h 查看方法文档-quick documentation ctrl+q 类的UML关系图-show uml popup ctrl+alt+u 定位某行-go to line/column ctrl+g 回溯变量或方法的来源-go to implementation(s) ctrl+alt+b 折叠方法实现-collapse all ctrl+shift+ - 展开方法实现-expand all ctrl+shift+ + 查找、替换与关闭 说明 快捷键 查找指定的结构 ctlr+f 快速查找：选中的Word快速定位到下一个-find next ctrl+l 查找与替换-replace ctrl+r 直接定位到当前行的首位-move caret to line start home 直接定位到当前行的末位 -move caret to line end end 查询当前元素在当前文件中的引用，然后按 F3 可以选择 ctrl+f7 全项目搜索文本-find in path \u0026hellip; ctrl+shift+f 关闭当前窗口-close ctrl+f4 调整格式 说明 快捷键 格式化代码-reformat code ctrl+alt+l 使用单行注释-comment with line comment ctrl + / 使用/取消多行注释-comment with block comment ctrl + shift + / 选中数行，整体往后移动-tab tab 选中数行，整体往前移动-prev tab shift + tab DEBUG 说明 快捷键 单步调试（不进入函数内部）- step over F8 单步调试（进入函数内部）- step into F7 强制单步调试（进入函数内部） - force step into alt+shift+f7 选择要进入的函数 - smart step into shift + F7 跳出函数 - step out shift + F8 运行到断点 - run to cursor alt + F9 继续执行，进入下一个断点或执行完程序 - resume program F9 停止 - stop Ctrl+F2 查看断点 - view breakpoints Ctrl+Shift+F8 关闭 - close Ctrl+F4 ","date":"2024-10-18T23:06:05+08:00","image":"https://kotoriforest.us.kg/p/1018-idea%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/cover_hu17497847842243478214.png","permalink":"https://kotoriforest.us.kg/p/1018-idea%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"IDEA中常用的快捷键"},{"content":"概述 为什么需要包装类 Java 提供了两个类型系统，基本数据类型与引用数据类型。使用基本数据类型效率高，然而当要使用只针对对象设计的 API 或新特性（例如泛型），怎么办呢？例如：\n1 2 3 4 5 6 7 8 9 10 // 情况 1：方法形参 Object 类的 equals(Object obj) // 情况 2：方法形参 ArrayList\u0026lt;T\u0026gt; 类的 add(Object obj) // ArrayList\u0026lt;T\u0026gt; 中没有如下的方法： add(int number) add(double d) add(boolean b) // 情况 3：泛型 Set\u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; Cllection\u0026lt;T\u0026gt; Map\u0026lt;K,V\u0026gt; 所以为了使得基本数据类型具备引用数据类型的相关特征（如：封装性、继承性和多态性），Java 为八种基本类型都引入了对应的包装类（封装类）。基本数据类型通过包装类有了类的特点，可以调用类中的方法。\n其中整形和浮点型的包装类继承自 Number，而布尔型和字符型的包装类继承自 Object。\n1 2 3 4 5 6 7 public class Test1 { public static void main(String[] args) { System.out.println(Byte.class.getSuperclass()); System.out.println(Boolean.class.getSuperclass()); System.out.println(Character.class.getSuperclass()); } } 1 2 3 class java.lang.Number class java.lang.Object class java.lang.Object 封装以后的，内存结构对比：\n1 2 3 4 5 6 public class Test1 { public static void main(String[] args) { int num = 520; Integer obj = new Integer(520); } } 自定义包装类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MyInteger { int value; public MyInteger() {} public MyInteger(int value) { this.value = value; } @Override public String toString() { return String.valueOf(value); } } 包装类与基本数据类型间的相互转换 在转换之前，我们先考虑一下为什么需要转换。基本数据类型转包装类的重要性在文章的开头已经提到了。那么我们还需要知道为什么包装类要转成基本数据类型，除了效率的原因外，还因为既然包装类是对象，而在 Java 中对象是不能进行加减乘除等算数运算的（String：幸好我的 + 是拼接的意思，不然我就被开除对象籍了😋），为了能够进行这些运算，就需要将包装类的对象转化为基本数据类型。\n装箱 装箱的意思是：把基本数据类型转为包装类对象。将基本类型转为包装类的对象，是为了使用专门为对象设计的API 和特性。\n装箱就一般来说有两种方法：\n使用包装类的构造器 [推荐] 调用包装类的静态工厂方法valueOf() 因为包装类的构造器在 JDK9 遭到废弃，所以不是很推荐用第一种方法来构建包装类了。\n1 2 3 4 5 6 7 // 使用构造函数函数 Integer obj1 = new Integer(4); // 参数为对应类型变量 Float f = new Float(“4.56”); // 参数为字符串 Long l = new Long(“asdf”); // 抛出异常 NumberFormatException // 使用包装类中的 valueOf 方法 Integer obj2 = Integer.valueOf(4); 说到装箱就不得不提一嘴 Boolean 的装箱了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Test1 { public static void main(String[] args) { Boolean b1 = new Boolean(true); // true Boolean b2 = new Boolean(\u0026#34;true\u0026#34;); // true Boolean b3 = Boolean.TRUE; // true Boolean b4 = Boolean.valueOf(true); // true Boolean b5 = new Boolean(\u0026#34;TrUe\u0026#34;); // true 使用字符串构建时会忽略大小写 Boolean b6 = Boolean.valueOf(\u0026#34;TRUE\u0026#34;); // 这里会抛出异常吗？ Boolean b7 = new Boolean(\u0026#34;1234567\u0026#34;); Boolean b8 = Boolean.valueOf(\u0026#34;abcdefg\u0026#34;); // 这里使用了 JDK5 的自动插装箱特性 之后再说 System.out.println(\u0026#34;b1 = \u0026#34; + b1); System.out.println(\u0026#34;b2 = \u0026#34; + b2); System.out.println(\u0026#34;b3 = \u0026#34; + b3); System.out.println(\u0026#34;b4 = \u0026#34; + b4); System.out.println(\u0026#34;b5 = \u0026#34; + b5); System.out.println(\u0026#34;b6 = \u0026#34; + b6); System.out.println(\u0026#34;b7 = \u0026#34; + b7); System.out.println(\u0026#34;b8 = \u0026#34; + b8); } } 你可能以为用 1234567 和 abcdefg 也会抛出异常，但很可惜，它并不会，而是被赋值为false。\n1 2 3 4 5 6 7 8 b1 = true b2 = true b3 = true b4 = true b5 = true b6 = true b7 = false b8 = false 这是为什么呢？让我们看看源码就知道了\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Deprecated(since=\u0026#34;9\u0026#34;, forRemoval = true) public Boolean(String s) { this(parseBoolean(s)); } public static Boolean valueOf(String s) { return parseBoolean(s) ? TRUE : FALSE; } // 我们发现它们都调用了 parseBoolean 这个方法，那么奥秘一定在其中 public static boolean parseBoolean(String s) { return \u0026#34;true\u0026#34;.equalsIgnoreCase(s); } 看过源码后我们就发现了，用字符串给Boolean赋值的原理是用传入的字符串与 `true` 做忽略大小写的比较，然后用比较出来的结果来赋值，通过源码我们不仅知道了只要传入的字符串不是 true 及其大小写变形得到的结果就是 false ，还知道了为什么用字符串构建会忽略大小写，原因是调用了字符串的 equalsIgnoreCase 方法。\n拆箱 拆箱就是把包装类对象拆为基本数据类型。将包装类对象转为基本数据类型一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的，如比较、算术等。\n拆箱就非常简单了，只需要调用对应包装类的 xxxValue() 方法就可以了。\n1 2 3 4 5 6 7 8 9 10 11 public class Test1 { public static void main(String[] args) { int i = Integer.valueOf(1).intValue(); boolean b = Boolean.valueOf(\u0026#34;TUre\u0026#34;).booleanValue(); double d = Double.valueOf(114514.0).doubleValue(); System.out.println(\u0026#34;i = \u0026#34; + i); System.out.println(\u0026#34;b = \u0026#34; + b); System.out.println(\u0026#34;d = \u0026#34; + d); } } 1 2 3 i = 1 b = false d = 114514.0 自动拆装箱 由于我们经常要做基本类型与包装类之间的转换，从 JDK5.0 开始，基本类型与包装类的装箱、拆箱动作可以自动完成。\n1 2 3 4 5 Integer i = 4; //自动装箱 相当于 Integer i = Integer.valueOf(4) // 等号右边: 将 i 对象转成基本数值(自动拆箱)，相当于 i.intValue() + 5 // 等号左边: 加法运算完成后，再次装箱，把基本数值转成对象。i = Integer.valueOf(i.intValue() + 5) i = i + 5; 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。\n1 2 Integer i = 1; Double d = 1; //错误的，1 是 int 类型 自动装箱和自动拆箱并不是什么高大上的东西，只是隐式帮我们调用了 valueOf() 和 xxxValue()方法而已。\n1 2 3 4 5 6 public class Test1 { public static void main(String[] args) { Integer ii = 4; int i = ii; } } 包装类对象的特点及注意事项 包装类缓存对象 为了引入这个特点，我们先看一个题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test2 { public static void main(String[] args) { Integer i1 = 1; Integer i2 = Integer.valueOf(1); Integer i3 = new Integer(1); System.out.println(i1 == i2); // true System.out.println(i1 == i3); // false Integer i4 = 114514; Integer i5 = Integer.valueOf(114514); Integer i6 = new Integer(114514); System.out.println(i4 == i5); // false System.out.println(i4 == i6); // false } } 我们知道对象之间的 == 是在比较对象的地址值，i1 和 i2 相等，说明 i1 和 i2 其实是同一个对象，而 i1 与 new 出来的 i3 不是同一个对象，结合上文我们说过自动装箱其实是调用了 valueOf() 方法，那是不是可以得出一个结论，通过 valueOf 得到的其实都是同一个对象呢？这个想法其实很接近真正的答案，不过先再让我们看看 i4 和 i5，我们发现 i4 和 i5 这两个valueOf 得到的对象又不是同一个了。为了解决这个问题，让我们来看看 valueOf 的源码。\n1 2 3 4 5 6 @IntrinsicCandidate public static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 我们又发现 valueOf 内部借助了一个 IntegerCache 类，那么奥妙肯定就在其中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 private static final class IntegerCache { static final int low = -128; static final int high; @Stable static final Integer[] cache; static Integer[] archivedCache; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;); if (integerCacheHighPropValue != null) { try { h = Math.max(parseInt(integerCacheHighPropValue), 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(h, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; // Load IntegerCache.archivedCache from archive, if possible CDS.initializeFromArchive(IntegerCache.class); int size = (high - low) + 1; // Use the archived cache if it exists and is large enough if (archivedCache == null || size \u0026gt; archivedCache.length) { Integer[] c = new Integer[size]; int j = low; for(int i = 0; i \u0026lt; c.length; i++) { c[i] = new Integer(j++); } archivedCache = c; } cache = archivedCache; // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } private IntegerCache() {} } 对于这份源码我们不需要完全看懂（我才不会告诉你我也没看多少呢😎），把这份代码精简一下大概就是这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private static final class IntegerCache { static final int low = -128; static final int high; @Stable static final Integer[] cache; static Integer[] archivedCache; static { int h = 127; high = h; int size = (high - low) + 1; // size = 256 if (archivedCache == null || size \u0026gt; archivedCache.length) { Integer[] c = new Integer[size]; int j = low; for(int i = 0; i \u0026lt; c.length; i++) { // 循环 size 次 c[i] = new Integer(j++); // c = {low, low + 1, ..., high - 1, high} 即 [-128, 127] } archivedCache = c; } cache = archivedCache; // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } private IntegerCache() {} } 这份代码是我断章取义的结果，只能用来大概理解，如有错误还请体谅并指正。\n总而言之，就是 IntegerCache 类中定义了一个长度为256的数组，其中存放了 [-128, 127] 对应的 Integer 对象，结合 valueOf() 方法就能得出：如果你通过 valueOf (或者自动包装)得到的 Integer 包装类对象所对应的值在[-128, 127]之间，那么就不会给你创建新对象，而是从 cache 数组中去取来给你用。。这也是为什么包装类要废弃构造函数，推荐使用valueOf 的原因，因为它可以通过 cache 数组来减少对象的创建，提升效率，而通过构造器 new 出来的对象是实打实创建了一个新的出来。\n1 2 3 4 5 6 7 8 9 10 /** * It is rarely appropriate to use this constructor. The static factory * {@link #valueOf(int)} is generally a better choice, as it is * likely to yield significantly better space and time performance. * 很少适合使用此构造函数。静态工厂 {@link valueOf（int）} 通常是更好的选择，因为它可能会产生明显更好的空间和时间性能。 */ @Deprecated(since=\u0026#34;9\u0026#34;, forRemoval = true) public Integer(int value) { this.value = value; } 当然了，不只 Integer 有缓存数组，很多包装类也有：\n包装类 缓存对象 Byte -128 ~ 127 Short -128 ~ 127 Integer -128 ~ 127 Long -128 ~ 127 Float 无 Double 无 Character 0 ~ 127 Boolean true 和 false 包装类对象不可变 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Test3 { public static void main(String[] args) { int i = 1; Integer j = new Integer(2); Circle c = new Circle(); change(i, j, c); System.out.println(\u0026#34;i = \u0026#34; + i); // 1 System.out.println(\u0026#34;j = \u0026#34; + j); // 2 System.out.println(\u0026#34;c.radius = \u0026#34; + c.radius); // 10.0 } /* * 方法的参数传递机制： * （1）基本数据类型：形参的修改完全不影响实参 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值 * 这类 Integer 等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了 */ public static void change(int a, Integer b, Circle c) { a += 10; Integer tmp = Integer.valueOf(b + 10); b += 10; // 等价于 b = Integer.valueOf(b + 10); System.out.println(b == tmp); // true c.radius += 10; } } class Circle { double radius; } b 的运算顺序为：先拆箱，把拆箱得到的数据与10相加，把相加得到的数作为 valueOf 的形参创建一个新的 Integer 对象。\n包装类与基本数据类型的默认值不同 我们在声明类的成员变量变量的时候，可能会声明包装类对象而不是基本数据类型。这时我们就要注意到，包装类是引用数据类型，所以它的默认值相对于基本数据类型发生了变化。\n1 2 3 4 5 6 7 8 9 10 public class Test1 { Integer integer; int i; public static void main(String[] args) { Test1 t = new Test1(); System.out.println(t.i); // 0 System.out.println(t.integer); // null } } 所以在使用时要注意一下它们类型变化带来的差异。\n类型转化问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test4 { public static void main(String[] args) { Integer i1 = 1000; double j1 = 1000; // true 会先将 i 自动拆箱为 int，然后根据基本数据类型“自动类型转换”规则，转为 double 进行比较 System.out.println(i1 == j1); Integer i2 = 1000; int j2 = 1000; System.out.println(i2 == j2); // true 会自动拆箱，按照基本数据类型进行比较 Integer i3 = 1; Double d3 = 1.0; System.out.println(i3 == d3); // 编译报错 Integer 与 Double 不能进行比较，其他包装类也是一样的 } } 字符串与基本数据类型的转化 基本数据类型转字符串 1 2 3 4 5 6 7 8 // 方法1 调用字符串重载的 valueOf() 方法 int a = 10; // String str = a; error String str = String.valueOf(a); // ok // 方法2 与空字符串进行拼接 int a = 10; String str = a + \u0026#34;\u0026#34;; // ok 字符串转基本类型 除了 Character 类之外，其他所有包装类都具有 parseXxx 静态方法可以将字符串参数转换为对应的基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的 int 基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的 long 基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的 double 基本类型。 字符串转为包装类，然后可以自动拆箱为基本数据类型。 public static Integer valueOf(String s)：将字符串参数转换为对应的 Integer 包装类，然后可以自动拆箱为 int 基本类型。 public static Long valueOf(String s)：将字符串参数转换为对应的 Long 包装类，然后可以自动拆箱为 long 基本类型。 public static Double valueOf(String s)：将字符串参数转换为对应的 Double 包装类，然后可以自动拆箱为 double 基本类型。 注意: 如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出 java.lang.NumberFormatException 异常。 1 2 3 4 5 6 7 8 9 10 // 方法1 int a = Integer.parseInt(\u0026#34;整数的字符串\u0026#34;); double d = Double.parseDouble(\u0026#34;小数的字符串\u0026#34;); boolean b = Boolean.parseBoolean(\u0026#34;true 或 false\u0026#34;); // 方法2 int i = new Integer(“12”); int a = Integer.valueOf(\u0026#34;整数的字符串\u0026#34;); double d = Double.valueOf(\u0026#34;小数的字符串\u0026#34;); boolean b = Boolean.valueOf(\u0026#34;true 或 false\u0026#34;); ","date":"2024-10-18T17:29:55+08:00","image":"https://kotoriforest.us.kg/p/1018-%E5%8C%85%E8%A3%85%E7%B1%BB/cover_hu14133844856861668868.png","permalink":"https://kotoriforest.us.kg/p/1018-%E5%8C%85%E8%A3%85%E7%B1%BB/","title":"包装类"},{"content":"下载并加载 jar 包 这里我们使用的是 JUnit4，首先我们先进入官网，然后拉到下方点击红框中的内容。\n我们先进入 ① 下载\n然后再进入 ② 下载\n如果你没有办法进入GitHub，你可以选择下载一个 Steam++，它提供免费的Github加速功能。或者直接下载我下好的jar包。\n下载完毕之后，你可以把 jar 包随便放在一个地方，但是我推荐新建一个文件夹。然后把所有的 jar 包都放在一起，这样可以方便管理。\n然后按下图导入 JUnit 库\n这里可以选择单独选择 jar 包，也可以选择一个文件夹，IDEA 会自动读取文件夹下 jar 包，这也是我推荐新建一个文件夹来存放 jar 包的原因。\n然后选择要使用这个库的模块，这样的话，被选择的模块就可以使用 JUnit 了。\n如果你还想在其他模块使用 JUnit\n然后选择 JUnit 所对应的库就可以了。\n有一点需要注意的是，在添加成功后，一定要把作用改为编译，否则在编译时就无法使用 JUnit。 使用 JUnit 如何使用我就不具体细说了，可以自己参考官方文档，我这里就提一点细节。\n@Test的使用条件 JUnit4版本，要求@Test标记的方法必须满足如下要求：\n所在的类必须是 public 的，非抽象的，包含唯一的无参构造器。 @Test 标记的方法本身必须是 public ，非抽象的，非静态的 void 无返回值， 无参数的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class JUnitTest { @Test public void test01() { System.out.println(\u0026#34;TestJUnit.test01\u0026#34;); } @Test public void test02() { System.out.println(\u0026#34;TestJUnit.test02\u0026#34;); } @Test public void test03() { System.out.println(\u0026#34;TestJUnit.test03\u0026#34;); } } @Test 修饰的方法在行号旁会有一个小箭头，点击那个小箭头就可以单独运行这个方法。\n让单元测试支持控制台输入 默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入（会提示此视图只读）。需要做如下设置：\n在 idea64.exe.vmoptions 配置文件中加入下面一行设置\n-Deditable.java.test.console=true\n然后重启 IDEA 就可以生效了。\n","date":"2024-10-18T12:21:54+08:00","image":"https://kotoriforest.us.kg/p/1018-%E5%9C%A8idea%E4%B8%AD%E4%BD%BF%E7%94%A8junit/cover_hu16502903383969207758.png","permalink":"https://kotoriforest.us.kg/p/1018-%E5%9C%A8idea%E4%B8%AD%E4%BD%BF%E7%94%A8junit/","title":"在IDEA中使用JUnit"},{"content":"枚举 概述 枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。\n在生活中枚举的例子数不胜数：\n星期：Monday（星期一 ）…… Sunday（星期天） 性别：Man（男） 、 Woman（女） 月份：January（1 月）\u0026hellip;\u0026hellip; December（12 月） 等等 在开发中，如果针对于某个类而言，其实例的个数是确定的，那么这个类就可以声明为枚举类，也推荐声明为枚举类。并且如果这个枚举类的实例就只有一个，就可以把这个枚举类看作是单例实现的。\n在 JDK5.0 之前，需要程序员自定义枚举类型。在 JDK5.0 之后， Java 支持 通过 enum 关键字来快速定义枚举类型。\n枚举类的使用 定义枚举类 JDK 5.0 之前 在JDK5.0 之前如何声明枚举类呢？\n私有化类的构造器，保证不能在类的外部创建其对象。 在类的内部创建枚举类的实例。声明为：public static final，对外暴露这些常量对象。 类中如果有实例变量，应该声明为 private final（建议，不是必须），并在构造器中初始化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Season { private final String SEASON_NAME; //季节的名称 private final String SEASON_DESC; //季节的描述 private Season(String seasonName, String seasonDesc) { this.SEASON_NAME = seasonName; this.SEASON_DESC = seasonDesc; } // Season 的实例 都是静态的 可以通过类名获得 // 实例都是 final 的 防止被用户在外部改变 如：Season.SPRING = null; // 可以写在类中的任意位置 public static final Season SPRING = new Season(\u0026#34;春天\u0026#34;, \u0026#34;春暖花开\u0026#34;); public static final Season SUMMER = new Season(\u0026#34;夏天\u0026#34;, \u0026#34;夏日炎炎\u0026#34;); public static final Season AUTUMN = new Season(\u0026#34;秋天\u0026#34;, \u0026#34;秋高气爽\u0026#34;); public static final Season WINTER = new Season(\u0026#34;冬天\u0026#34;, \u0026#34;白雪皑皑\u0026#34;); @Override public String toString() { return \u0026#34;Season{\u0026#34; + \u0026#34;SEASON_NAME=\u0026#39;\u0026#34; + SEASON_NAME + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, SEASON_DESC=\u0026#39;\u0026#34; + SEASON_DESC + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } class SeasonTest { public static void main(String[] args) { System.out.println(Season.SPRING); System.out.println(Season.SUMMER); System.out.println(Season.AUTUMN); System.out.println(Season.WINTER); } } 1 2 3 4 Season{SEASON_NAME=\u0026#39;春天\u0026#39;, SEASON_DESC=\u0026#39;春暖花开\u0026#39;} Season{SEASON_NAME=\u0026#39;夏天\u0026#39;, SEASON_DESC=\u0026#39;夏日炎炎\u0026#39;} Season{SEASON_NAME=\u0026#39;秋天\u0026#39;, SEASON_DESC=\u0026#39;秋高气爽\u0026#39;} Season{SEASON_NAME=\u0026#39;冬天\u0026#39;, SEASON_DESC=\u0026#39;白雪皑皑\u0026#39;} JDK 5.0 之后 在 JDK 5.0 之后，定义枚举类就非常方便了\n1 2 3 4 5 6 // []中的内容表示可选 // \u0026lt;\u0026gt;中的内容表示必选 [public] enum \u0026lt;enum name\u0026gt; { 常量对象列表; (不同对象之间用\u0026#39;,\u0026#39;连接， 最后以\u0026#39;;\u0026#39;结尾) [对象的实例变量列表]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 举例 public enum Season { // 定义枚举实例必须这么写 不能添加额外的东西 public static final 也不行！ // 必须在枚举类的最上面 既常量列表的上面不能有其他语句 SPRING(\u0026#34;春暖花开\u0026#34;), SUMMER(\u0026#34;夏日炎炎\u0026#34;), AUTUMN(\u0026#34;秋高气爽\u0026#34;), WINTER(\u0026#34;白雪皑皑\u0026#34;); private final String SEASON_DESC; //季节的描述 // 这里的 private 可以省略 private Season(String seasonDesc) { this.SEASON_DESC = seasonDesc; } } 如果枚举类中没有实例变量，那么定义出来枚举类就可以变成短短的一行\n1 2 3 public enum Week { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; } enum定义的要求和特定：\n枚举类的常量对象列表必须在枚举类的首行。因为是常量，所以建议大写。 列出的实例系统会自动添加 public static final 修饰。不需要也不能手动添加。 如果常量对象列表后面没有其他代码，那么 \u0026rsquo;;\u0026rsquo; 可以省略，否则不可以省略。 编译器给枚举类默认提供的是 private 的无参构造器，如果枚举类需要的是无参构造器就不需要声明，写常量对象列表时也不用加括号和参数。 如果枚举类需要的是有参构造器就需要手动定义，有参构造器的 private 修饰符可以省略，调用有参构造器的方法就是在常量对象名后面加括号和实参列表就可以。 枚举类可以作为枚举类和其他类的内部类。 枚举类默认继承的是 java.lang.Enum 类，因此不能再继承其他的类型。但是枚举类可以实现接口。 JDK5.0 之后 switch 支持枚举类型， case 后面可以写枚举常量名，无需添加枚举类作为限定（当然加了也不会错）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 interface IWeek { void showWeek(); } public enum Week implements IWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; @Override public void showWeek() { System.out.println(\u0026#34;Week::showWeek()\u0026#34;); } } class TestWeek { public static void main(String[] args) { Week week = Week.MONDAY; System.out.println(week.getClass()); System.out.println(week.getClass().getSuperclass()); System.out.println(week.getClass().getSuperclass().getSuperclass()); switch (week) { case Week.MONDAY: System.out.println(\u0026#34;MONDAY\u0026#34;); break; case TUESDAY: System.out.println(\u0026#34;TUESDAY\u0026#34;); break; case WEDNESDAY: System.out.println(\u0026#34;WEDNESDAY\u0026#34;); break; case THURSDAY: System.out.println(\u0026#34;THURSDAY\u0026#34;); break; case FRIDAY: System.out.println(\u0026#34;FRIDAY\u0026#34;); break; case SATURDAY: System.out.println(\u0026#34;SATURDAY\u0026#34;); break; case SUNDAY: System.out.println(\u0026#34;SUNDAY\u0026#34;); break; default: break; } } } 1 2 3 4 class uskg.kotoriforest.enumtest.Week class java.lang.Enum java.lang.Enum MONDAY 开发中，当需要定义一组常量时，强烈建议使用枚举类。\nenum中的常用方法 既然enum继承自Enum，那么肯定会得到一些方法\n1 2 3 4 5 String toString(); // 默认返回的是常量名（对象名），可以继续手动重写该方法！ static 枚举类型[] values(); //返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法 static 枚举类型 valueOf(String name); // 可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”(即定义枚举类对象时写下的字面值，如 SPRING 的名字就是 SPRING)。如不是，会有运行时异常：IllegalArgumentException。 String name() // 得到当前枚举常量的名称。建议优先使用toString()。 int ordinal() // 返回当前枚举常量的次序号，默认从0开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.Scanner; public enum Week { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; } class TestEnumMethod { public static void main(String[] args) { //values() Week[] values = Week.values(); for (Week value : values) { //ordinal()、name() System.out.println((value.ordinal() + 1) + \u0026#34;-\u0026gt;\u0026#34; + value.name()); } System.out.println(\u0026#34;------------------------\u0026#34;); Scanner input = new Scanner(System.in); System.out.print(\u0026#34;请输入星期值：\u0026#34;); int weekValue = input.nextInt(); Week week = values[weekValue - 1]; //toString() System.out.println(week); System.out.print(\u0026#34;请输入星期名：\u0026#34;); String weekName = input.next(); //valueOf() week = Week.valueOf(weekName); System.out.println(week); input.close(); } } 1 2 3 4 5 6 7 8 9 10 11 12 1-\u0026gt;MONDAY 2-\u0026gt;TUESDAY 3-\u0026gt;WEDNESDAY 4-\u0026gt;THURSDAY 5-\u0026gt;FRIDAY 6-\u0026gt;SATURDAY 7-\u0026gt;SUNDAY ------------------------ 请输入星期值：3 WEDNESDAY 请输入星期名：SUNDAY SUNDAY 实现接口的枚举类 和普通 Java 类一样，枚举类可以实现一个或多个接口。 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要在枚举类中统一实现该方法即可。 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！ enum A implements 接口1，接口2 { //抽象方法的实现 } // 枚举类的实例可以独立重写抽象方法! enum A implements 接口1，接口2 { 常量名1(参数) { //抽象方法的实现或重写 }, 常量名2(参数) { //抽象方法的实现或重写 }, //... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 interface Info { void show(); } //使用 enum 关键字定义枚举类 public enum Season implements Info { // 创建枚举类中的对象,声明在 enum 枚举类的首位 SPRING(\u0026#34;春天\u0026#34;, \u0026#34;春暖花开\u0026#34;) { public void show() { System.out.println(\u0026#34;春天在哪里？\u0026#34;); } }, SUMMER(\u0026#34;夏天\u0026#34;, \u0026#34;夏日炎炎\u0026#34;) { public void show() { System.out.println(\u0026#34;宁静的夏天\u0026#34;); } }, AUTUMN(\u0026#34;秋天\u0026#34;, \u0026#34;秋高气爽\u0026#34;), WINTER(\u0026#34;冬天\u0026#34;, \u0026#34;白雪皑皑\u0026#34;) { public void show() { System.out.println(\u0026#34;2002 年的第一场雪\u0026#34;); } }; // 声明每个对象拥有的属性 用 private final 修饰 private final String SEASON_NAME; private final String SEASON_DESC; // 私有化类的构造器 private Season(String seasonName, String seasonDesc) { this.SEASON_NAME = seasonName; this.SEASON_DESC = seasonDesc; } public String getSEASON_NAME() { return SEASON_NAME; } public String getSEASON_DESC() { return SEASON_DESC; } // 为枚举类实现抽象方法 // 如果每个枚举对象都实现了独属于自己的抽象方法 就可以不为抽象类实现 否则就要实现 这里 AUTUMN 没有实现自己的抽象方法 // 所以 AUTUMN 就会调用枚举类实现的方法 即这个方法 @Override public void show() { System.out.println(\u0026#34;这是一个平凡的季节\u0026#34;); } } class SeasonTest { public static void main(String[] args) { for (Season season : Season.values()) { season.show(); } } } 使用枚举来实现单例模式 1 2 3 4 5 6 7 8 9 10 11 // jdk5.0 之前使用枚举类定义单例模式 public class Singleton { public static final Singleton INSTANCE = new Singleton(); private Singleton() {} } // jdk5.0 及之后使用枚举类定义单例模式 public enum Singleton { instance; // public static final /* enum 默认的构造函数就是 private 的 所以不需要自己声明 */ } 注解 概述 注解（Annotation）是从 JDK5.0 开始引入，以“@注解名”在代码中存在。例如：\n@Override @Deprecated @SuppressWarnings( value=\u0026quot; \u0026quot; ) Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “key=value” 键值对中。\n注解可以在类编译、运行时进行加载，体现不同的功能。\n注解与注释的区别 注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解不同于单行注释和多行注释\n单行注释和多行注释是给程序员看的。 注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。 注解的重要性 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。但是在 JavaEE 和 Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。注解是一种趋势，一定程度上可以说：框架 = 注解 \u0026#43; 反射 \u0026#43; 设计模式。\n常见注解的作用 生成文档相关的注解 1 2 3 4 5 6 7 @author 标明开发该类模块的作者，多个作者之间使用\u0026#39;,\u0026#39;分割 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @since 从哪个版本开始增加的 @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是 void 就不能写 @exception 对方法可能抛出的异常进行说明，如果方法没有用 throws 显式抛出的异常就不能写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class JavadocTest { /** * 程序的主方法，程序的入口 * @param args String[] 命令行参数 */ public static void main(String[] args) {} /** * 求圆面积的方法 * @param radius double 半径值 * @return double 圆的面积 */ public static double getArea(double radius){ return Math.PI * radius * radius; } } 在编译时进行格式检查 ( JDK 内置的三个基本注解) 1 2 3 @Override: 限定于重写父类方法，该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class AnnotationTest { public static void main(String[] args) { @SuppressWarnings(\u0026#34;unused\u0026#34;) int a = 10; } @Deprecated(since = \u0026#34;8\u0026#34;) public void print() { System.out.println(\u0026#34;过时的方法\u0026#34;); } @Override public String toString() { return \u0026#34;重写的toString()\u0026#34;; } } 跟踪代码依赖性，实现替代配置文件功能 Servlet3.0 提供了注解（annotation），使得不再需要在 web.xml 文件中进行 Servlet 的部署。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 使用注解完成相关功能 @WebServlet(\u0026#34;/login\u0026#34;) public class LoginServlet extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) { } protected void doPost(HttpServletRequest request, HttpServletResp onse response) { doGet(request, response); } } // Spring 框架中关于“事务”的管理 @Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3) public void buyBook(String username, String isbn) { // 查询书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); // 更新库存 bookShopDao.updateBookStock(isbn); // 更新用户的余额 bookShopDao.updateUserAccount(username, price); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 使用配置文件完成相关功能 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;LoginServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.servlet.LoginServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;LoginServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/login\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!-- 配置事务属性 --\u0026gt; \u0026lt;tx:advice transaction-manager=\u0026#34;dataSourceTransactionManager\u0026#34; id=\u0026#34;tx Advice\u0026#34;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!-- 配置每个方法使用的事务属性 --\u0026gt; \u0026lt;tx:methodname=\u0026#34;buyBook\u0026#34;propagation=\u0026#34;REQUIRES_NEW\u0026#34;isolation=\u0026#34;READ_COMMITTED\u0026#34; readonly=\u0026#34;false\u0026#34;timeout=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; 三个最基本的注解 @Override 用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！ 只能标记在方法上。 它会被编译器程序读取。 @Override 主要就是用来检查是否重写了父类或接口的的某个方法。你可能会感到困惑，正常人谁会写错啊，有必要特地写一个注解来检查吗？您还真别说，真不一定写的对。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class SuperClass { public void showMe1Message() { System.out.println(\u0026#34;SuperClass.showMe1Message\u0026#34;); } } public class AnnotationTest extends SuperClass { // 这里乍看过去好像是重写了父类的方法 但是其实并没有 // 在父类中是 \u0026#39;1\u0026#39; 而在子类中是 \u0026#39;l\u0026#39; public void showMelMessage() { System.out.println(\u0026#34;AnnotationTest.showMelMessage\u0026#34;); } } 如果你成功发现了这些细微差别，那么恭喜你，你的眼睛比我好多了，因为我真的有时候看快了就没看出来。没看出来也不要紧，因为@Override就是来解决这个问题的。\n如果你没有成功重写父类的方法的话，@Override就会报错，我还不信这么刺眼的红线你都看不见。\n但说实话，如果你用的是 IDEA ，Alt + Insrrt就能解决这个问题了，IDEA真是太方便了！\n@Deprecated 用于表示被标记的数据已经过时，不推荐使用。 可以用于修饰属性、方法、构造、类、包、局部变量、参数。 它会被编译器程序读取。 说实话这个注解就目前来说，我根本就用不到，也就是在 JDK 的官方库中才有机会见到。\n注解中的 since 标明从 jdk 的哪个版本开始废弃，forRemoval标识被注解的函数等会不会在将来被删除，所以如果一个函数、类……被标记为Deprecated就最好不要在程序中使用了。如果你使用了，编译器可能会给你报错误或者警告，但是不要紧，还是可以正常编译运行的。\n@SuppressWarnings 抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息。 可以用于修饰类、属性、方法、构造、局部变量、参数。 它会被编译器程序读取。 可以指定的警告类型有（部分）： 警告类型 说明 all 抑制所有警告 unchecked 抑制与未检查的作业相关的警告 unused 抑制与未用的程式码及停用的程式码相关的警告 deprecation 抑制与淘汰的相关警告 nls 抑制与非 nls 字串文字相关的警告 null 抑制与空值分析相关的警告 rawtypes 抑制与使用 raw 类型相关的警告 static access 抑制与静态存取不正确相关的警告 static method 抑制与可能宣告为 static 的方法相关的警告 super 抑制与置换方法相关但不含 super 呼叫的警告 元注解 元注解简而言之来说就是作用于注解的注解。\nJDK1.5 在 java.lang.annotation 包定义了4个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。\n@Target：用于描述注解的使用范围 可以通过枚举类型 ElementType 的 10 个常量对象来指定 @Retention：用于描述注解的生命周期 可以通过枚举类型 RetentionPolicy 的 3 个常量对象来指定，分别是SOURCE （源代码）、 CLASS （字节码）、 RUNTIME （运行时） 唯有 RUNTIME 阶段才能被反射读取到。 @Documented：表明这个注解应该被 javadoc工具记录。 @Inherited：允许子类继承父类中的注解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public enum ElementType { /** Class, interface (including annotation interface), enum, or record * declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation interface declaration (Formerly known as an annotation type.) */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE, /** * Module declaration. * * @since 9 */ MODULE, /** * Record component * * @jls 8.10.3 Record Members * @jls 9.7.4 Where Annotations May Appear * * @since 16 */ RECORD_COMPONENT; } 1 2 3 4 5 6 7 8 9 10 11 12 13 // @Deprecated 的定义 package java.lang; import java.lang.annotation.*; import static java.lang.annotation.ElementType.*; @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE}) public @interface Deprecated { String since() default \u0026#34;\u0026#34;; boolean forRemoval() default false; } 自定义注解的使用 一个完整的注解应该包含三个部分：（1）声明 （2）使用 （3）读取\n1 2 3 4 [元注解] [修饰符] @interface \u0026lt;注解名\u0026gt; { [成员列表] } 自定义注解可以通过四个元注解 @Retention, @Target, @Inherited, @Documented 分别说明它的声明周期，使用位置，是否被继承，是否被生成到 API 文档中。\nAnnotation 的成员在 Annotation 的定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型：String 类型、 Class 类型、 enum 类型、 Annotation 类型、以上所有类型的数组。可以使用 default 关键字为抽象方法指定默认返回值。\n如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是 “方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为 value，则可以省略 “ value= ”，所以如果注解只有一个抽象方法成员，建议使用方法名 value 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; // 定义自定义注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { // 定义带有默认值的属性 String name() default \u0026#34;DefaultName\u0026#34;; // 如果没有指定，使用默认值 int age() default 18; // 如果没有指定，使用默认值 String[] tags() default {\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;}; // 数组类型默认值 } // 使用了默认值 @MyAnnotation class Example1 { } // 这里覆盖了默认值 @MyAnnotation(name = \u0026#34;John\u0026#34;, age = 25, tags = {\u0026#34;developer\u0026#34;, \u0026#34;java\u0026#34;}) class Example2 { } 自定义注解必须配上注解的信息处理流程才有意义。我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。\n反射我还没学到，等之后再说，嘿嘿🤭\n","date":"2024-10-16T00:48:39+08:00","image":"https://kotoriforest.us.kg/p/1016-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/cover_hu7516527291003337567.png","permalink":"https://kotoriforest.us.kg/p/1016-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/","title":"简单介绍枚举和注解"},{"content":"概述 ​\t接口就是规范，定义的是一组规则，体现了现实世界中”如果你是 / 要\u0026hellip;则必须能\u0026hellip;”的思想。继承是一个\u0026quot;是不是\u0026quot;的 is-a 关系，而接口实现则是 \u0026ldquo;能不能\u0026quot;的 has-a 关系。\n​\t例如：Java 程序是否能够连接使用某种数据库产品，那么要看该数据库产品能否实现 Java 设计的 JDBC 规范\n​\t接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。\n接口 接口的定义 ​\t接口的定义与类的定义方式相似，只是将 class 关键字换成了 interface 关键字。它同样也会被编译成 .class 文件，但一定要明确它并不是类，而是另外一种引用数据类型。\n1 2 3 4 5 6 7 8 9 10 package uskg.kotoriforest.api; public interface Interface { } class Test1 implements Interface { public static void main(String[] args) { } } 在 interface 内部，我们可以声明属性和方法。其中属性必须使用 public static final 修饰，但其实interface中的属性默认就是 public static final 的，所以可以不写😓；而方法则需要声明为 public abstract，同样的，因为接口中的方法的默认修饰就为 public abstract，所以也可以不写。\n​\t上述是 jdk8 之前的规范，在 jdk8 及以后，接口内可以声明静态方法和默认方法。在 jdk9 及以后，接口内还可以声明私有方法。但我们主要还是使用 public abstract 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public interface Interface { public static final int SIZE = 100; // int SIZE = 100; 这样也是可以的 public abstract void method(); // void method(); OK！ // 默认方法 其中 public 可以省略 但建议保留 public default void method2() { System.out.println(\u0026#34;method2\u0026#34;); } // 静态方法 其中 public 可以省略 但建议保留 public static void method3() { System.out.println(\u0026#34;method3\u0026#34;); } // 静态方法 可以用 static 修饰 // 如果是非 static 就是给接口内部的默认方法调用的 // 如果是 static 就是给接口内部的默认方法和静态方法调用的 private void method4() { System.out.println(\u0026#34;method4\u0026#34;); } // public 可以省略 // 接口也能像类一样 拥有自己的内部接口😋 public interface Inner { } } ​\t说完可以在接口内声明的，还需要提一嘴不能在接口内声明的，构造器、代码块都是不能出现于接口内部的，因为接口并不能被实例化，且接口中没有成员变量需要动态初始化。\n1 2 3 4 5 public interface Interface { Interface() {} // error {} // error static {} // error } 接口的使用 类实现接口 ​\t接口不能创建对象，但是可以被类实现。类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。\n1 2 3 4 5 6 7 8 9 [修饰符] class [class name] implements [interface name] { // [必须] 实现接口中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } [修饰符] class [class name] extends [super class name] implements [interface name] { // [必须] 实现接口中的抽象方法 如果父类也是抽象类也需要实现父类中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } 如果接口的实现类是非抽象类，那么必须重写接口中所有抽象方法。\n默认方法可以选择保留原实现，也可以重写。\n重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了。\n接口中的静态方法和私有方法不能被继承也不能被重写。\n接口的多实现 ​\t在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。所以，一个类能继承一个父类，同时实现多个接口。\n1 2 3 4 5 6 7 8 9 [修饰符] class [class name] implements [interface name1], [interface name2], [interface name3]... { // [必须] 实现接口中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } [修饰符] class [class name] extends [super class name] [interface name1], [interface name2], [interface name3]... { // [必须] 实现接口中的抽象方法 如果父类也是抽象类也需要实现父类中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } ​\t接口中有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface Interface { void method1(); void method2(); } interface Api { void method1(); void method3(); } class Test implements Interface, Api{ @Override public void method1() { // 同时重写了 Interface 和 Api 中的 method1 System.out.println(\u0026#34;method1\u0026#34;); } @Override public void method3() { System.out.println(\u0026#34;method2\u0026#34;); } @Override public void method2() { System.out.println(\u0026#34;method3\u0026#34;); } } ​\t类针对于接口的多实现，在一定程度上弥补了单继承的局限性（只能拿到声明，不能拿到实现）。\n接口的多继承 ​\t一个接口能继承另一个或者多个接口，接口的继承也使用 extends 关键字，子接口会继承父接口的方法。\n​\t一个子类只能有一个父类，但谁说一个子接口只能有一个父接口了😎。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface Interface { void method1(); default void method2(){} } interface Api { static void method3() {} private static void method4() {} } interface Outer extends Interface, Api { default void method5() { method1(); method2(); Api.method3(); // 子接口不能继承父接口的 static 和 private 方法 } } class Test implements Outer { @Override public void method1() { } @Override public void method2() { Outer.super.method2(); } @Override public void method5() { Outer.super.method5(); } } 接口与实现类对象构成多态引用 ​\t实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你 new 的实现类对象实现的方法体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public interface IOut { void goOut(); } class TheRich implements IOut { public void goOut() { System.out.println(\u0026#34;坐飞机头等舱\u0026#34;); } } class ThePoor implements IOut { public void goOut() { System.out.println(\u0026#34;坐快车硬座\u0026#34;); } } class Test { public static void main(String[] args) { IOut theRich = new TheRich(); theRich.goOut(); System.out.println(\u0026#34;--------------------\u0026#34;); IOut thePoor = new ThePoor(); thePoor.goOut(); } } 1 2 3 坐飞机头等舱 -------------------- 坐快车硬座 接口在 jdk8 和 jdk9 中的新特性 使用接口的静态成员 ​\t接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Interface { int NUMBER = 0X1234; static void method(){ System.out.println(\u0026#34;method\u0026#34;); }; } class Test implements Interface{ public static void main(String[] args) { System.out.println(Interface.NUMBER); // OK System.out.println(Test.NUMBER); // OK Interface.method(); // OK Test.method(); // error: static 方法通过其的定义接口调用 不能通过实现类调用 } } 在 Java 中，接口不能继承父接口的 static 方法。这是因为 static 方法属于接口本身，而不是它的实现类或子接口。\nstatic 方法在 Java 接口中只能通过接口名直接调用，不能通过实现类或子接口进行调用。 子接口或实现类不会继承父接口的 static 方法。 这是 Java 的设计决定：static 方法属于定义它的接口，不能通过继承传播。 回忆一下 Java 中的继承对 static 方法的处理方式：\n在 Java 中，子类不能继承父类的 static 方法，但子类可以通过类名直接调用父类的 static 方法。这是因为 static 方法是属于类本身的，而不是属于某个实例或子类。\nstatic 方法属于类，而不是对象：static 方法在类加载时就存在，属于类本身，不依赖于类的实例。 不能通过继承来重写 static 方法：子类不会真正“继承”父类的 static 方法，而是拥有它自己的 static 方法空间。如果子类定义了一个相同名字的 static 方法，这种行为被称为“隐藏”而不是“重写”。 调用方式：static 方法应通过类名调用，即使子类定义了相同的方法，也只能通过类名调用，不应通过实例调用。 使用接口的默认方法 对于接口的静态方法，直接使用接口名进行调用即可，也只能使用接口名进行调用，不能通过实现类的对象进行调用。 对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用，接口不能直接创建对象，只能创建实现类的对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface Interface { // default 可以看作是用来顶替 abstract 的位置的 // 如果什么也不写会默认是 abstract 而 default 就是为了声明该函数不是抽象函数，具有函数体 public default void method1() { System.out.println(\u0026#34;method1\u0026#34;); } default void method2() { System.out.println(\u0026#34;method2\u0026#34;); } default void method3() { // default 函数可以调用其他的default、static、private、private static 方法 method1(); method2(); System.out.println(\u0026#34;method3\u0026#34;); } } class Test implements Interface { @Override public void method1() { // Interface.super.method1(); System.out.println(\u0026#34;Test::method1\u0026#34;); } public static void main(String[] args) { Test test = new Test(); test.method3(); } } 1 2 3 Test::method1 method2 method3 ​\t接口中声明的默认方法可以被实现类继承，实现类在没有重写此方法的情况下，默认调用接口中声明的默认方法。如果实现类重写了此方法，则调用的是自己重写的方法。\n使用接口的私有方法 ​\t接口的私有方法非常简单，你可以简单的认为它是私有的默认方法，但是不能使用 default 关键字。\n1 2 3 4 interface Interface { // 可以带上 static private void method() {} } ​\t私有方法的主要作用就是将静态方法和默认方法中重复出现的代码提取出来，然后进行复用。\njdk8 中相关冲突问题 默认方法冲突 接口冲突 当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？\n无论你多难抉择，最终都是要做出选择的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Interface { default void method() { System.out.println(\u0026#34;Interface method\u0026#34;); } } interface Api { default void method() { System.out.println(\u0026#34;Api method\u0026#34;); } } class Test implements Interface, Api { // error: Test 从类型 Interface 和 Api 继承 method() 的不相关默认值 } ​\t类实现了两个接口，而两个接口定义了同名同参数（相同签名）的默认方法。则实现类在没有重写这两个接口默认方法的条件下，会报错。我们把这个叫做接口冲突。（如果是抽象方法就不会有这个问题，因为抽象方法一定要重写😋）\n1 2 3 4 5 6 7 8 9 10 11 class Test implements Interface, Api { @Override public void method() { // 解决方案1: 保留其中一个父接口的实现 下面二选一 // Interface.super.method(); // Api.super.method(); // 解决方案2: 完全重写 System.out.println(\u0026#34;Test method\u0026#34;); } } ​\t当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？\n​\t当然也是需要重写的了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface Interface { default void method() { System.out.println(\u0026#34;Interface method\u0026#34;); } } interface Api { default void method() { System.out.println(\u0026#34;Api method\u0026#34;); } } interface IProgram extends Interface, Api { @Override default void method() { // Interface.super.method(); // Api.super.method(); System.out.println(\u0026#34;IProgram method\u0026#34;); } } 子接口重写默认方法时，default 关键字必须保留。\n子类重写默认方法时，default 关键字不可以保留。\n类优先原则 ​\t子类（或实现类）继承了父类并实现了接口，并且父类和接口中声明了签名相同的方法。默认的，子类（或实现类）在没有重写此方法的情况下，调用的是父类中的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public interface Interface { default void method1() { System.out.println(\u0026#34;Interface method1\u0026#34;); } void method2(); } class SuperClass { public void method1() { System.out.println(\u0026#34;SuperClass method1\u0026#34;); } public void method2() { System.out.println(\u0026#34;SuperClass method2\u0026#34;); } } class SubClass extends SuperClass implements Interface { public static void main(String[] args) { SubClass subClass = new SubClass(); subClass.method1(); subClass.method2(); System.out.println(\u0026#34;-----------------------------\u0026#34;); new SubClass() { @Override public void method1() { System.out.println(\u0026#34;SubClass method1\u0026#34;); } }.method1(); } } 1 2 3 4 SuperClass method1 SuperClass method2 ----------------------------- SubClass method1 ​\t如果现在我们有一个实现类重写了父类和接口中的签名相同的方法，那么我们如何分别调用实现类自己的、父类的、父接口中的签名相同的方法呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class SubClass extends SuperClass implements Interface { @Override public void method1() { System.out.println(\u0026#34;SubClass method1\u0026#34;); } public void exec() { method1(); // 调用自己的 super.method1(); // 调用父类的 Interface.super.method1(); // 调用父接口的 } public static void main(String[] args) { new SubClass().exec(); } } 1 2 3 SubClass method1 SuperClass method1 Interface method1 常量冲突问题 问题出现的原因：\n当子类既继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。 子类同时实现多个接口，而多个接口存在相同同名常量。 ​\t上述条件只要满足其一，在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class SuperClass { int x = 1;} interface SuperInterface { int x = 2; int y = 2; } interface MotherInterface { int x = 3; } class SubClass extends SuperClass implements SuperInterface, MotherInterface { public void method(){ // System.out.println(\u0026#34;x = \u0026#34; + x);//模糊不清 System.out.println(\u0026#34;super.x = \u0026#34; + super.x); System.out.println(\u0026#34;SuperInterface.x = \u0026#34; + SuperInterface.x); System.out.println(\u0026#34;MotherInterface.x = \u0026#34; + MotherInterface.x); System.out.println(\u0026#34;y = \u0026#34; + y);//没有重名问题，可以直接访问 } public static void main(String[] args) { new SubClass().method(); } } 1 2 3 4 super.x = 1 SuperInterface.x = 2 MotherInterface.x = 3 y = 2 接口的总结与面试题 总结 接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。\n声明接口用 interface ，接口的成员声明有限制：\n① 公共的静态常量\n② 公共的抽象方法\n③ 公共的默认方法 （ JDK8.0 及以上）\n④ 公共的静态方法 （ JDK8.0 及以上）\n⑤ 私有方法 （ JDK9.0 及以上）\n类可以实现接口，关键字是 implements ，并且支持多实现。如果实现类不是抽象类就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（ extends ）在前，实现 （ implements ）在后。\n接口可以继承接口，关键字是 extends ，而且支持多继承。\n接口的默认方法可以选择重写或不重写。如果有冲突问题就需要另行处理。子类重写父接口的默认方法，要去掉 default ，子接口重写父接口的默认方法，不要去掉 default。\n接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过 “ 接口名.静态方法名 ” 进行调用。\n面试题 为什么接口中只能声明公共的静态的常量？\n因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。\n为什么 JDK 8.0 之后允许接口定义静态方法和默认方法呢？它违反了接口作为一个抽象标准定义的概念。\n静态方法：因为之前的标准类库设计中，有很多 Collection / Colletions 或者 Path / Paths 这样成对的接口和类，后面的类中是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对 API，不如把静态方法直接定义到接口中使用和维护更方便。 默认方法：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8 中对 Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。 为什么JDK1.9 要允许接口定义私有方法呢？我们说接口是规范，规范是需要公开让大家遵守的。\n因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。\n接口与抽象类之间的对比 ","date":"2024-10-14T21:50:33+08:00","image":"https://kotoriforest.us.kg/p/1014-%E6%8E%A5%E5%8F%A3interface/cover_hu12441902767145371651.png","permalink":"https://kotoriforest.us.kg/p/1014-%E6%8E%A5%E5%8F%A3interface/","title":"接口interface"}]