[{"content":"概述 为什么需要包装类 Java 提供了两个类型系统，基本数据类型与引用数据类型。使用基本数据类型效率高，然而当要使用只针对对象设计的 API 或新特性（例如泛型），怎么办呢？例如：\n1 2 3 4 5 6 7 8 9 10 // 情况 1：方法形参 Object 类的 equals(Object obj) // 情况 2：方法形参 ArrayList\u0026lt;T\u0026gt; 类的 add(Object obj) // ArrayList\u0026lt;T\u0026gt; 中没有如下的方法： add(int number) add(double d) add(boolean b) // 情况 3：泛型 Set\u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; Cllection\u0026lt;T\u0026gt; Map\u0026lt;K,V\u0026gt; 所以为了使得基本数据类型具备引用数据类型的相关特征（如：封装性、继承性和多态性），Java 为八种基本类型都引入了对应的包装类（封装类）。基本数据类型通过包装类有了类的特点，可以调用类中的方法。\n其中整形和浮点型的包装类继承自 Number，而布尔型和字符型的包装类继承自 Object。\n1 2 3 4 5 6 7 public class Test1 { public static void main(String[] args) { System.out.println(Byte.class.getSuperclass()); System.out.println(Boolean.class.getSuperclass()); System.out.println(Character.class.getSuperclass()); } } 1 2 3 class java.lang.Number class java.lang.Object class java.lang.Object 封装以后的，内存结构对比：\n1 2 3 4 5 6 public class Test1 { public static void main(String[] args) { int num = 520; Integer obj = new Integer(520); } } 自定义包装类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MyInteger { int value; public MyInteger() {} public MyInteger(int value) { this.value = value; } @Override public String toString() { return String.valueOf(value); } } 包装类与基本数据类型间的相互转换 在转换之前，我们先考虑一下为什么需要转换。基本数据类型转包装类的重要性在文章的开头已经提到了。那么我们还需要知道为什么包装类要转成基本数据类型，除了效率的原因外，还因为既然包装类是对象，而在 Java 中对象是不能进行加减乘除等算数运算的（String：幸好我的 + 是拼接的意思，不然我就被开除对象籍了😋），为了能够进行这些运算，就需要将包装类的对象转化为基本数据类型。\n装箱 装箱的意思是：把基本数据类型转为包装类对象。将基本类型转为包装类的对象，是为了使用专门为对象设计的API 和特性。\n装箱就一般来说有两种方法：\n使用包装类的构造器 [推荐] 调用包装类的静态工厂方法valueOf() 因为包装类的构造器在 JDK9 遭到废弃，所以不是很推荐用第一种方法来构建包装类了。\n1 2 3 4 5 6 7 // 使用构造函数函数 Integer obj1 = new Integer(4); // 参数为对应类型变量 Float f = new Float(“4.56”); // 参数为字符串 Long l = new Long(“asdf”); // 抛出异常 NumberFormatException // 使用包装类中的 valueOf 方法 Integer obj2 = Integer.valueOf(4); 说到装箱就不得不提一嘴 Boolean 的装箱了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Test1 { public static void main(String[] args) { Boolean b1 = new Boolean(true); // true Boolean b2 = new Boolean(\u0026#34;true\u0026#34;); // true Boolean b3 = Boolean.TRUE; // true Boolean b4 = Boolean.valueOf(true); // true Boolean b5 = new Boolean(\u0026#34;TrUe\u0026#34;); // true 使用字符串构建时会忽略大小写 Boolean b6 = Boolean.valueOf(\u0026#34;TRUE\u0026#34;); // 这里会抛出异常吗？ Boolean b7 = new Boolean(\u0026#34;1234567\u0026#34;); Boolean b8 = Boolean.valueOf(\u0026#34;abcdefg\u0026#34;); // 这里使用了 JDK5 的自动插装箱特性 之后再说 System.out.println(\u0026#34;b1 = \u0026#34; + b1); System.out.println(\u0026#34;b2 = \u0026#34; + b2); System.out.println(\u0026#34;b3 = \u0026#34; + b3); System.out.println(\u0026#34;b4 = \u0026#34; + b4); System.out.println(\u0026#34;b5 = \u0026#34; + b5); System.out.println(\u0026#34;b6 = \u0026#34; + b6); System.out.println(\u0026#34;b7 = \u0026#34; + b7); System.out.println(\u0026#34;b8 = \u0026#34; + b8); } } 你可能以为用 1234567 和 abcdefg 也会抛出异常，但很可惜，它并不会，而是被赋值为false。\n1 2 3 4 5 6 7 8 b1 = true b2 = true b3 = true b4 = true b5 = true b6 = true b7 = false b8 = false 这是为什么呢？让我们看看源码就知道了\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Deprecated(since=\u0026#34;9\u0026#34;, forRemoval = true) public Boolean(String s) { this(parseBoolean(s)); } public static Boolean valueOf(String s) { return parseBoolean(s) ? TRUE : FALSE; } // 我们发现它们都调用了 parseBoolean 这个方法，那么奥秘一定在其中 public static boolean parseBoolean(String s) { return \u0026#34;true\u0026#34;.equalsIgnoreCase(s); } 看过源码后我们就发现了，用字符串给Boolean赋值的原理是用传入的字符串与 `true` 做忽略大小写的比较，然后用比较出来的结果来赋值，通过源码我们不仅知道了只要传入的字符串不是 true 及其大小写变形得到的结果就是 false ，还知道了为什么用字符串构建会忽略大小写，原因是调用了字符串的 equalsIgnoreCase 方法。\n拆箱 拆箱就是把包装类对象拆为基本数据类型。将包装类对象转为基本数据类型一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的，如比较、算术等。\n拆箱就非常简单了，只需要调用对应包装类的 xxxValue() 方法就可以了。\n1 2 3 4 5 6 7 8 9 10 11 public class Test1 { public static void main(String[] args) { int i = Integer.valueOf(1).intValue(); boolean b = Boolean.valueOf(\u0026#34;TUre\u0026#34;).booleanValue(); double d = Double.valueOf(114514.0).doubleValue(); System.out.println(\u0026#34;i = \u0026#34; + i); System.out.println(\u0026#34;b = \u0026#34; + b); System.out.println(\u0026#34;d = \u0026#34; + d); } } 1 2 3 i = 1 b = false d = 114514.0 自动拆装箱 由于我们经常要做基本类型与包装类之间的转换，从 JDK5.0 开始，基本类型与包装类的装箱、拆箱动作可以自动完成。\n1 2 3 4 5 Integer i = 4; //自动装箱 相当于 Integer i = Integer.valueOf(4) // 等号右边: 将 i 对象转成基本数值(自动拆箱)，相当于 i.intValue() + 5 // 等号左边: 加法运算完成后，再次装箱，把基本数值转成对象。i = Integer.valueOf(i.intValue() + 5) i = i + 5; 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。\n1 2 Integer i = 1; Double d = 1; //错误的，1 是 int 类型 自动装箱和自动拆箱并不是什么高大上的东西，只是隐式帮我们调用了 valueOf() 和 xxxValue()方法而已。\n1 2 3 4 5 6 public class Test1 { public static void main(String[] args) { Integer ii = 4; int i = ii; } } 包装类对象的特点及注意事项 包装类缓存对象 为了引入这个特点，我们先看一个题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test2 { public static void main(String[] args) { Integer i1 = 1; Integer i2 = Integer.valueOf(1); Integer i3 = new Integer(1); System.out.println(i1 == i2); // true System.out.println(i1 == i3); // false Integer i4 = 114514; Integer i5 = Integer.valueOf(114514); Integer i6 = new Integer(114514); System.out.println(i4 == i5); // false System.out.println(i4 == i6); // false } } 我们知道对象之间的 == 是在比较对象的地址值，i1 和 i2 相等，说明 i1 和 i2 其实是同一个对象，而 i1 与 new 出来的 i3 不是同一个对象，结合上文我们说过自动装箱其实是调用了 valueOf() 方法，那是不是可以得出一个结论，通过 valueOf 得到的其实都是同一个对象呢？这个想法其实很接近真正的答案，不过先再让我们看看 i4 和 i5，我们发现 i4 和 i5 这两个valueOf 得到的对象又不是同一个了。为了解决这个问题，让我们来看看 valueOf 的源码。\n1 2 3 4 5 6 @IntrinsicCandidate public static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 我们又发现 valueOf 内部借助了一个 IntegerCache 类，那么奥妙肯定就在其中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 private static final class IntegerCache { static final int low = -128; static final int high; @Stable static final Integer[] cache; static Integer[] archivedCache; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;); if (integerCacheHighPropValue != null) { try { h = Math.max(parseInt(integerCacheHighPropValue), 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(h, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; // Load IntegerCache.archivedCache from archive, if possible CDS.initializeFromArchive(IntegerCache.class); int size = (high - low) + 1; // Use the archived cache if it exists and is large enough if (archivedCache == null || size \u0026gt; archivedCache.length) { Integer[] c = new Integer[size]; int j = low; for(int i = 0; i \u0026lt; c.length; i++) { c[i] = new Integer(j++); } archivedCache = c; } cache = archivedCache; // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } private IntegerCache() {} } 对于这份源码我们不需要完全看懂（我才不会告诉你我也没看多少呢😎），把这份代码精简一下大概就是这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private static final class IntegerCache { static final int low = -128; static final int high; @Stable static final Integer[] cache; static Integer[] archivedCache; static { int h = 127; high = h; int size = (high - low) + 1; // size = 256 if (archivedCache == null || size \u0026gt; archivedCache.length) { Integer[] c = new Integer[size]; int j = low; for(int i = 0; i \u0026lt; c.length; i++) { // 循环 size 次 c[i] = new Integer(j++); // c = {low, low + 1, ..., high - 1, high} 即 [-128, 127] } archivedCache = c; } cache = archivedCache; // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } private IntegerCache() {} } 这份代码是我断章取义的结果，只能用来大概理解，如有错误还请体谅并指正。\n总而言之，就是 IntegerCache 类中定义了一个长度为256的数组，其中存放了 [-128, 127] 对应的 Integer 对象，结合 valueOf() 方法就能得出：如果你通过 valueOf (或者自动包装)得到的 Integer 包装类对象所对应的值在[-128, 127]之间，那么就不会给你创建新对象，而是从 cache 数组中去取来给你用。。这也是为什么包装类要废弃构造函数，推荐使用valueOf 的原因，因为它可以通过 cache 数组来减少对象的创建，提升效率，而通过构造器 new 出来的对象是实打实创建了一个新的出来。\n1 2 3 4 5 6 7 8 9 10 /** * It is rarely appropriate to use this constructor. The static factory * {@link #valueOf(int)} is generally a better choice, as it is * likely to yield significantly better space and time performance. * 很少适合使用此构造函数。静态工厂 {@link valueOf（int）} 通常是更好的选择，因为它可能会产生明显更好的空间和时间性能。 */ @Deprecated(since=\u0026#34;9\u0026#34;, forRemoval = true) public Integer(int value) { this.value = value; } 当然了，不只 Integer 有缓存数组，很多包装类也有：\n包装类 缓存对象 Byte -128 ~ 127 Short -128 ~ 127 Integer -128 ~ 127 Long -128 ~ 127 Float 无 Double 无 Character 0 ~ 127 Boolean true 和 false 包装类对象不可变 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Test3 { public static void main(String[] args) { int i = 1; Integer j = new Integer(2); Circle c = new Circle(); change(i, j, c); System.out.println(\u0026#34;i = \u0026#34; + i); // 1 System.out.println(\u0026#34;j = \u0026#34; + j); // 2 System.out.println(\u0026#34;c.radius = \u0026#34; + c.radius); // 10.0 } /* * 方法的参数传递机制： * （1）基本数据类型：形参的修改完全不影响实参 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值 * 这类 Integer 等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了 */ public static void change(int a, Integer b, Circle c) { a += 10; Integer tmp = Integer.valueOf(b + 10); b += 10; // 等价于 b = Integer.valueOf(b + 10); System.out.println(b == tmp); // true c.radius += 10; } } class Circle { double radius; } b 的运算顺序为：先拆箱，把拆箱得到的数据与10相加，把相加得到的数作为 valueOf 的形参创建一个新的 Integer 对象。\n包装类与基本数据类型的默认值不同 我们在声明类的成员变量变量的时候，可能会声明包装类对象而不是基本数据类型。这时我们就要注意到，包装类是引用数据类型，所以它的默认值相对于基本数据类型发生了变化。\n1 2 3 4 5 6 7 8 9 10 public class Test1 { Integer integer; int i; public static void main(String[] args) { Test1 t = new Test1(); System.out.println(t.i); // 0 System.out.println(t.integer); // null } } 所以在使用时要注意一下它们类型变化带来的差异。\n类型转化问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test4 { public static void main(String[] args) { Integer i1 = 1000; double j1 = 1000; // true 会先将 i 自动拆箱为 int，然后根据基本数据类型“自动类型转换”规则，转为 double 进行比较 System.out.println(i1 == j1); Integer i2 = 1000; int j2 = 1000; System.out.println(i2 == j2); // true 会自动拆箱，按照基本数据类型进行比较 Integer i3 = 1; Double d3 = 1.0; System.out.println(i3 == d3); // 编译报错 Integer 与 Double 不能进行比较，其他包装类也是一样的 } } 字符串与基本数据类型的转化 基本数据类型转字符串 1 2 3 4 5 6 7 8 // 方法1 调用字符串重载的 valueOf() 方法 int a = 10; // String str = a; error String str = String.valueOf(a); // ok // 方法2 与空字符串进行拼接 int a = 10; String str = a + \u0026#34;\u0026#34;; // ok 字符串转基本类型 除了 Character 类之外，其他所有包装类都具有 parseXxx 静态方法可以将字符串参数转换为对应的基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的 int 基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的 long 基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的 double 基本类型。 字符串转为包装类，然后可以自动拆箱为基本数据类型。 public static Integer valueOf(String s)：将字符串参数转换为对应的 Integer 包装类，然后可以自动拆箱为 int 基本类型。 public static Long valueOf(String s)：将字符串参数转换为对应的 Long 包装类，然后可以自动拆箱为 long 基本类型。 public static Double valueOf(String s)：将字符串参数转换为对应的 Double 包装类，然后可以自动拆箱为 double 基本类型。 注意: 如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出 java.lang.NumberFormatException 异常。 1 2 3 4 5 6 7 8 9 10 // 方法1 int a = Integer.parseInt(\u0026#34;整数的字符串\u0026#34;); double d = Double.parseDouble(\u0026#34;小数的字符串\u0026#34;); boolean b = Boolean.parseBoolean(\u0026#34;true 或 false\u0026#34;); // 方法2 int i = new Integer(“12”); int a = Integer.valueOf(\u0026#34;整数的字符串\u0026#34;); double d = Double.valueOf(\u0026#34;小数的字符串\u0026#34;); boolean b = Boolean.valueOf(\u0026#34;true 或 false\u0026#34;); ","date":"2024-10-18T17:29:55+08:00","image":"https://kotoriforest.us.kg/p/1018-%E5%8C%85%E8%A3%85%E7%B1%BB/cover_hu14133844856861668868.png","permalink":"https://kotoriforest.us.kg/p/1018-%E5%8C%85%E8%A3%85%E7%B1%BB/","title":"包装类"},{"content":"下载并加载 jar 包 这里我们使用的是 JUnit4，首先我们先进入官网，然后拉到下方点击红框中的内容。\n我们先进入 ① 下载\n然后再进入 ② 下载\n如果你没有办法进入GitHub，你可以选择下载一个 Steam++，它提供免费的Github加速功能。或者直接下载我下好的jar包。\n下载完毕之后，你可以把 jar 包随便放在一个地方，但是我推荐新建一个文件夹。然后把所有的 jar 包都放在一起，这样可以方便管理。\n然后按下图导入 JUnit 库\n这里可以选择单独选择 jar 包，也可以选择一个文件夹，IDEA 会自动读取文件夹下 jar 包，这也是我推荐新建一个文件夹来存放 jar 包的原因。\n然后选择要使用这个库的模块，这样的话，被选择的模块就可以使用 JUnit 了。\n如果你还想在其他模块使用 JUnit\n然后选择 JUnit 所对应的库就可以了。\n有一点需要注意的是，在添加成功后，一定要把作用改为编译，否则在编译时就无法使用 JUnit。 使用 JUnit 如何使用我就不具体细说了，可以自己参考官方文档，我这里就提一点细节。\n@Test的使用条件 JUnit4版本，要求@Test标记的方法必须满足如下要求：\n所在的类必须是 public 的，非抽象的，包含唯一的无参构造器。 @Test 标记的方法本身必须是 public ，非抽象的，非静态的 void 无返回值， 无参数的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class JUnitTest { @Test public void test01() { System.out.println(\u0026#34;TestJUnit.test01\u0026#34;); } @Test public void test02() { System.out.println(\u0026#34;TestJUnit.test02\u0026#34;); } @Test public void test03() { System.out.println(\u0026#34;TestJUnit.test03\u0026#34;); } } @Test 修饰的方法在行号旁会有一个小箭头，点击那个小箭头就可以单独运行这个方法。\n让单元测试支持控制台输入 默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入（会提示此视图只读）。需要做如下设置：\n在 idea64.exe.vmoptions 配置文件中加入下面一行设置\n-Deditable.java.test.console=true\n然后重启 IDEA 就可以生效了。\n","date":"2024-10-18T12:21:54+08:00","image":"https://kotoriforest.us.kg/p/1018-%E5%9C%A8idea%E4%B8%AD%E4%BD%BF%E7%94%A8junit/cover_hu16502903383969207758.png","permalink":"https://kotoriforest.us.kg/p/1018-%E5%9C%A8idea%E4%B8%AD%E4%BD%BF%E7%94%A8junit/","title":"在IDEA中使用JUnit"},{"content":"枚举 概述 枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。\n在生活中枚举的例子数不胜数：\n星期：Monday（星期一 ）…… Sunday（星期天） 性别：Man（男） 、 Woman（女） 月份：January（1 月）\u0026hellip;\u0026hellip; December（12 月） 等等 在开发中，如果针对于某个类而言，其实例的个数是确定的，那么这个类就可以声明为枚举类，也推荐声明为枚举类。并且如果这个枚举类的实例就只有一个，就可以把这个枚举类看作是单例实现的。\n在 JDK5.0 之前，需要程序员自定义枚举类型。在 JDK5.0 之后， Java 支持 通过 enum 关键字来快速定义枚举类型。\n枚举类的使用 定义枚举类 JDK 5.0 之前 在JDK5.0 之前如何声明枚举类呢？\n私有化类的构造器，保证不能在类的外部创建其对象。 在类的内部创建枚举类的实例。声明为：public static final，对外暴露这些常量对象。 类中如果有实例变量，应该声明为 private final（建议，不是必须），并在构造器中初始化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Season { private final String SEASON_NAME; //季节的名称 private final String SEASON_DESC; //季节的描述 private Season(String seasonName, String seasonDesc) { this.SEASON_NAME = seasonName; this.SEASON_DESC = seasonDesc; } // Season 的实例 都是静态的 可以通过类名获得 // 实例都是 final 的 防止被用户在外部改变 如：Season.SPRING = null; // 可以写在类中的任意位置 public static final Season SPRING = new Season(\u0026#34;春天\u0026#34;, \u0026#34;春暖花开\u0026#34;); public static final Season SUMMER = new Season(\u0026#34;夏天\u0026#34;, \u0026#34;夏日炎炎\u0026#34;); public static final Season AUTUMN = new Season(\u0026#34;秋天\u0026#34;, \u0026#34;秋高气爽\u0026#34;); public static final Season WINTER = new Season(\u0026#34;冬天\u0026#34;, \u0026#34;白雪皑皑\u0026#34;); @Override public String toString() { return \u0026#34;Season{\u0026#34; + \u0026#34;SEASON_NAME=\u0026#39;\u0026#34; + SEASON_NAME + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, SEASON_DESC=\u0026#39;\u0026#34; + SEASON_DESC + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } class SeasonTest { public static void main(String[] args) { System.out.println(Season.SPRING); System.out.println(Season.SUMMER); System.out.println(Season.AUTUMN); System.out.println(Season.WINTER); } } 1 2 3 4 Season{SEASON_NAME=\u0026#39;春天\u0026#39;, SEASON_DESC=\u0026#39;春暖花开\u0026#39;} Season{SEASON_NAME=\u0026#39;夏天\u0026#39;, SEASON_DESC=\u0026#39;夏日炎炎\u0026#39;} Season{SEASON_NAME=\u0026#39;秋天\u0026#39;, SEASON_DESC=\u0026#39;秋高气爽\u0026#39;} Season{SEASON_NAME=\u0026#39;冬天\u0026#39;, SEASON_DESC=\u0026#39;白雪皑皑\u0026#39;} JDK 5.0 之后 在 JDK 5.0 之后，定义枚举类就非常方便了\n1 2 3 4 5 6 // []中的内容表示可选 // \u0026lt;\u0026gt;中的内容表示必选 [public] enum \u0026lt;enum name\u0026gt; { 常量对象列表; (不同对象之间用\u0026#39;,\u0026#39;连接， 最后以\u0026#39;;\u0026#39;结尾) [对象的实例变量列表]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 举例 public enum Season { // 定义枚举实例必须这么写 不能添加额外的东西 public static final 也不行！ // 必须在枚举类的最上面 既常量列表的上面不能有其他语句 SPRING(\u0026#34;春暖花开\u0026#34;), SUMMER(\u0026#34;夏日炎炎\u0026#34;), AUTUMN(\u0026#34;秋高气爽\u0026#34;), WINTER(\u0026#34;白雪皑皑\u0026#34;); private final String SEASON_DESC; //季节的描述 // 这里的 private 可以省略 private Season(String seasonDesc) { this.SEASON_DESC = seasonDesc; } } 如果枚举类中没有实例变量，那么定义出来枚举类就可以变成短短的一行\n1 2 3 public enum Week { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; } enum定义的要求和特定：\n枚举类的常量对象列表必须在枚举类的首行。因为是常量，所以建议大写。 列出的实例系统会自动添加 public static final 修饰。不需要也不能手动添加。 如果常量对象列表后面没有其他代码，那么 \u0026rsquo;;\u0026rsquo; 可以省略，否则不可以省略。 编译器给枚举类默认提供的是 private 的无参构造器，如果枚举类需要的是无参构造器就不需要声明，写常量对象列表时也不用加括号和参数。 如果枚举类需要的是有参构造器就需要手动定义，有参构造器的 private 修饰符可以省略，调用有参构造器的方法就是在常量对象名后面加括号和实参列表就可以。 枚举类可以作为枚举类和其他类的内部类。 枚举类默认继承的是 java.lang.Enum 类，因此不能再继承其他的类型。但是枚举类可以实现接口。 JDK5.0 之后 switch 支持枚举类型， case 后面可以写枚举常量名，无需添加枚举类作为限定（当然加了也不会错）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 interface IWeek { void showWeek(); } public enum Week implements IWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; @Override public void showWeek() { System.out.println(\u0026#34;Week::showWeek()\u0026#34;); } } class TestWeek { public static void main(String[] args) { Week week = Week.MONDAY; System.out.println(week.getClass()); System.out.println(week.getClass().getSuperclass()); System.out.println(week.getClass().getSuperclass().getSuperclass()); switch (week) { case Week.MONDAY: System.out.println(\u0026#34;MONDAY\u0026#34;); break; case TUESDAY: System.out.println(\u0026#34;TUESDAY\u0026#34;); break; case WEDNESDAY: System.out.println(\u0026#34;WEDNESDAY\u0026#34;); break; case THURSDAY: System.out.println(\u0026#34;THURSDAY\u0026#34;); break; case FRIDAY: System.out.println(\u0026#34;FRIDAY\u0026#34;); break; case SATURDAY: System.out.println(\u0026#34;SATURDAY\u0026#34;); break; case SUNDAY: System.out.println(\u0026#34;SUNDAY\u0026#34;); break; default: break; } } } 1 2 3 4 class uskg.kotoriforest.enumtest.Week class java.lang.Enum java.lang.Enum MONDAY 开发中，当需要定义一组常量时，强烈建议使用枚举类。\nenum中的常用方法 既然enum继承自Enum，那么肯定会得到一些方法\n1 2 3 4 5 String toString(); // 默认返回的是常量名（对象名），可以继续手动重写该方法！ static 枚举类型[] values(); //返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法 static 枚举类型 valueOf(String name); // 可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”(即定义枚举类对象时写下的字面值，如 SPRING 的名字就是 SPRING)。如不是，会有运行时异常：IllegalArgumentException。 String name() // 得到当前枚举常量的名称。建议优先使用toString()。 int ordinal() // 返回当前枚举常量的次序号，默认从0开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.Scanner; public enum Week { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; } class TestEnumMethod { public static void main(String[] args) { //values() Week[] values = Week.values(); for (Week value : values) { //ordinal()、name() System.out.println((value.ordinal() + 1) + \u0026#34;-\u0026gt;\u0026#34; + value.name()); } System.out.println(\u0026#34;------------------------\u0026#34;); Scanner input = new Scanner(System.in); System.out.print(\u0026#34;请输入星期值：\u0026#34;); int weekValue = input.nextInt(); Week week = values[weekValue - 1]; //toString() System.out.println(week); System.out.print(\u0026#34;请输入星期名：\u0026#34;); String weekName = input.next(); //valueOf() week = Week.valueOf(weekName); System.out.println(week); input.close(); } } 1 2 3 4 5 6 7 8 9 10 11 12 1-\u0026gt;MONDAY 2-\u0026gt;TUESDAY 3-\u0026gt;WEDNESDAY 4-\u0026gt;THURSDAY 5-\u0026gt;FRIDAY 6-\u0026gt;SATURDAY 7-\u0026gt;SUNDAY ------------------------ 请输入星期值：3 WEDNESDAY 请输入星期名：SUNDAY SUNDAY 实现接口的枚举类 和普通 Java 类一样，枚举类可以实现一个或多个接口。 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要在枚举类中统一实现该方法即可。 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！ enum A implements 接口1，接口2 { //抽象方法的实现 } // 枚举类的实例可以独立重写抽象方法! enum A implements 接口1，接口2 { 常量名1(参数) { //抽象方法的实现或重写 }, 常量名2(参数) { //抽象方法的实现或重写 }, //... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 interface Info { void show(); } //使用 enum 关键字定义枚举类 public enum Season implements Info { // 创建枚举类中的对象,声明在 enum 枚举类的首位 SPRING(\u0026#34;春天\u0026#34;, \u0026#34;春暖花开\u0026#34;) { public void show() { System.out.println(\u0026#34;春天在哪里？\u0026#34;); } }, SUMMER(\u0026#34;夏天\u0026#34;, \u0026#34;夏日炎炎\u0026#34;) { public void show() { System.out.println(\u0026#34;宁静的夏天\u0026#34;); } }, AUTUMN(\u0026#34;秋天\u0026#34;, \u0026#34;秋高气爽\u0026#34;), WINTER(\u0026#34;冬天\u0026#34;, \u0026#34;白雪皑皑\u0026#34;) { public void show() { System.out.println(\u0026#34;2002 年的第一场雪\u0026#34;); } }; // 声明每个对象拥有的属性 用 private final 修饰 private final String SEASON_NAME; private final String SEASON_DESC; // 私有化类的构造器 private Season(String seasonName, String seasonDesc) { this.SEASON_NAME = seasonName; this.SEASON_DESC = seasonDesc; } public String getSEASON_NAME() { return SEASON_NAME; } public String getSEASON_DESC() { return SEASON_DESC; } // 为枚举类实现抽象方法 // 如果每个枚举对象都实现了独属于自己的抽象方法 就可以不为抽象类实现 否则就要实现 这里 AUTUMN 没有实现自己的抽象方法 // 所以 AUTUMN 就会调用枚举类实现的方法 即这个方法 @Override public void show() { System.out.println(\u0026#34;这是一个平凡的季节\u0026#34;); } } class SeasonTest { public static void main(String[] args) { for (Season season : Season.values()) { season.show(); } } } 使用枚举来实现单例模式 1 2 3 4 5 6 7 8 9 10 11 // jdk5.0 之前使用枚举类定义单例模式 public class Singleton { public static final Singleton INSTANCE = new Singleton(); private Singleton() {} } // jdk5.0 及之后使用枚举类定义单例模式 public enum Singleton { instance; // public static final /* enum 默认的构造函数就是 private 的 所以不需要自己声明 */ } 注解 概述 注解（Annotation）是从 JDK5.0 开始引入，以“@注解名”在代码中存在。例如：\n@Override @Deprecated @SuppressWarnings( value=\u0026quot; \u0026quot; ) Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “key=value” 键值对中。\n注解可以在类编译、运行时进行加载，体现不同的功能。\n注解与注释的区别 注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解不同于单行注释和多行注释\n单行注释和多行注释是给程序员看的。 注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。 注解的重要性 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。但是在 JavaEE 和 Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。注解是一种趋势，一定程度上可以说：框架 = 注解 \u0026#43; 反射 \u0026#43; 设计模式。\n常见注解的作用 生成文档相关的注解 1 2 3 4 5 6 7 @author 标明开发该类模块的作者，多个作者之间使用\u0026#39;,\u0026#39;分割 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @since 从哪个版本开始增加的 @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是 void 就不能写 @exception 对方法可能抛出的异常进行说明，如果方法没有用 throws 显式抛出的异常就不能写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class JavadocTest { /** * 程序的主方法，程序的入口 * @param args String[] 命令行参数 */ public static void main(String[] args) {} /** * 求圆面积的方法 * @param radius double 半径值 * @return double 圆的面积 */ public static double getArea(double radius){ return Math.PI * radius * radius; } } 在编译时进行格式检查 ( JDK 内置的三个基本注解) 1 2 3 @Override: 限定于重写父类方法，该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class AnnotationTest { public static void main(String[] args) { @SuppressWarnings(\u0026#34;unused\u0026#34;) int a = 10; } @Deprecated(since = \u0026#34;8\u0026#34;) public void print() { System.out.println(\u0026#34;过时的方法\u0026#34;); } @Override public String toString() { return \u0026#34;重写的toString()\u0026#34;; } } 跟踪代码依赖性，实现替代配置文件功能 Servlet3.0 提供了注解（annotation），使得不再需要在 web.xml 文件中进行 Servlet 的部署。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 使用注解完成相关功能 @WebServlet(\u0026#34;/login\u0026#34;) public class LoginServlet extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) { } protected void doPost(HttpServletRequest request, HttpServletResp onse response) { doGet(request, response); } } // Spring 框架中关于“事务”的管理 @Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3) public void buyBook(String username, String isbn) { // 查询书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); // 更新库存 bookShopDao.updateBookStock(isbn); // 更新用户的余额 bookShopDao.updateUserAccount(username, price); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 使用配置文件完成相关功能 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;LoginServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.servlet.LoginServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;LoginServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/login\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!-- 配置事务属性 --\u0026gt; \u0026lt;tx:advice transaction-manager=\u0026#34;dataSourceTransactionManager\u0026#34; id=\u0026#34;tx Advice\u0026#34;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!-- 配置每个方法使用的事务属性 --\u0026gt; \u0026lt;tx:methodname=\u0026#34;buyBook\u0026#34;propagation=\u0026#34;REQUIRES_NEW\u0026#34;isolation=\u0026#34;READ_COMMITTED\u0026#34; readonly=\u0026#34;false\u0026#34;timeout=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; 三个最基本的注解 @Override 用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！ 只能标记在方法上。 它会被编译器程序读取。 @Override 主要就是用来检查是否重写了父类或接口的的某个方法。你可能会感到困惑，正常人谁会写错啊，有必要特地写一个注解来检查吗？您还真别说，真不一定写的对。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class SuperClass { public void showMe1Message() { System.out.println(\u0026#34;SuperClass.showMe1Message\u0026#34;); } } public class AnnotationTest extends SuperClass { // 这里乍看过去好像是重写了父类的方法 但是其实并没有 // 在父类中是 \u0026#39;1\u0026#39; 而在子类中是 \u0026#39;l\u0026#39; public void showMelMessage() { System.out.println(\u0026#34;AnnotationTest.showMelMessage\u0026#34;); } } 如果你成功发现了这些细微差别，那么恭喜你，你的眼睛比我好多了，因为我真的有时候看快了就没看出来。没看出来也不要紧，因为@Override就是来解决这个问题的。\n如果你没有成功重写父类的方法的话，@Override就会报错，我还不信这么刺眼的红线你都看不见。\n但说实话，如果你用的是 IDEA ，Alt + Insrrt就能解决这个问题了，IDEA真是太方便了！\n@Deprecated 用于表示被标记的数据已经过时，不推荐使用。 可以用于修饰属性、方法、构造、类、包、局部变量、参数。 它会被编译器程序读取。 说实话这个注解就目前来说，我根本就用不到，也就是在 JDK 的官方库中才有机会见到。\n注解中的 since 标明从 jdk 的哪个版本开始废弃，forRemoval标识被注解的函数等会不会在将来被删除，所以如果一个函数、类……被标记为Deprecated就最好不要在程序中使用了。如果你使用了，编译器可能会给你报错误或者警告，但是不要紧，还是可以正常编译运行的。\n@SuppressWarnings 抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息。 可以用于修饰类、属性、方法、构造、局部变量、参数。 它会被编译器程序读取。 可以指定的警告类型有（部分）： 警告类型 说明 all 抑制所有警告 unchecked 抑制与未检查的作业相关的警告 unused 抑制与未用的程式码及停用的程式码相关的警告 deprecation 抑制与淘汰的相关警告 nls 抑制与非 nls 字串文字相关的警告 null 抑制与空值分析相关的警告 rawtypes 抑制与使用 raw 类型相关的警告 static access 抑制与静态存取不正确相关的警告 static method 抑制与可能宣告为 static 的方法相关的警告 super 抑制与置换方法相关但不含 super 呼叫的警告 元注解 元注解简而言之来说就是作用于注解的注解。\nJDK1.5 在 java.lang.annotation 包定义了4个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。\n@Target：用于描述注解的使用范围 可以通过枚举类型 ElementType 的 10 个常量对象来指定 @Retention：用于描述注解的生命周期 可以通过枚举类型 RetentionPolicy 的 3 个常量对象来指定，分别是SOURCE （源代码）、 CLASS （字节码）、 RUNTIME （运行时） 唯有 RUNTIME 阶段才能被反射读取到。 @Documented：表明这个注解应该被 javadoc工具记录。 @Inherited：允许子类继承父类中的注解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public enum ElementType { /** Class, interface (including annotation interface), enum, or record * declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation interface declaration (Formerly known as an annotation type.) */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE, /** * Module declaration. * * @since 9 */ MODULE, /** * Record component * * @jls 8.10.3 Record Members * @jls 9.7.4 Where Annotations May Appear * * @since 16 */ RECORD_COMPONENT; } 1 2 3 4 5 6 7 8 9 10 11 12 13 // @Deprecated 的定义 package java.lang; import java.lang.annotation.*; import static java.lang.annotation.ElementType.*; @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE}) public @interface Deprecated { String since() default \u0026#34;\u0026#34;; boolean forRemoval() default false; } 自定义注解的使用 一个完整的注解应该包含三个部分：（1）声明 （2）使用 （3）读取\n1 2 3 4 [元注解] [修饰符] @interface \u0026lt;注解名\u0026gt; { [成员列表] } 自定义注解可以通过四个元注解 @Retention, @Target, @Inherited, @Documented 分别说明它的声明周期，使用位置，是否被继承，是否被生成到 API 文档中。\nAnnotation 的成员在 Annotation 的定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型：String 类型、 Class 类型、 enum 类型、 Annotation 类型、以上所有类型的数组。可以使用 default 关键字为抽象方法指定默认返回值。\n如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是 “方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为 value，则可以省略 “ value= ”，所以如果注解只有一个抽象方法成员，建议使用方法名 value 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; // 定义自定义注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { // 定义带有默认值的属性 String name() default \u0026#34;DefaultName\u0026#34;; // 如果没有指定，使用默认值 int age() default 18; // 如果没有指定，使用默认值 String[] tags() default {\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;}; // 数组类型默认值 } // 使用了默认值 @MyAnnotation class Example1 { } // 这里覆盖了默认值 @MyAnnotation(name = \u0026#34;John\u0026#34;, age = 25, tags = {\u0026#34;developer\u0026#34;, \u0026#34;java\u0026#34;}) class Example2 { } 自定义注解必须配上注解的信息处理流程才有意义。我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。\n反射我还没学到，等之后再说，嘿嘿🤭\n","date":"2024-10-16T00:48:39+08:00","image":"https://kotoriforest.us.kg/p/1016-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/cover_hu7516527291003337567.png","permalink":"https://kotoriforest.us.kg/p/1016-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/","title":"简单介绍枚举和注解"},{"content":"概述 ​\t接口就是规范，定义的是一组规则，体现了现实世界中”如果你是 / 要\u0026hellip;则必须能\u0026hellip;”的思想。继承是一个\u0026quot;是不是\u0026quot;的 is-a 关系，而接口实现则是 \u0026ldquo;能不能\u0026quot;的 has-a 关系。\n​\t例如：Java 程序是否能够连接使用某种数据库产品，那么要看该数据库产品能否实现 Java 设计的 JDBC 规范\n​\t接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。\n接口 接口的定义 ​\t接口的定义与类的定义方式相似，只是将 class 关键字换成了 interface 关键字。它同样也会被编译成 .class 文件，但一定要明确它并不是类，而是另外一种引用数据类型。\n1 2 3 4 5 6 7 8 9 10 package uskg.kotoriforest.api; public interface Interface { } class Test1 implements Interface { public static void main(String[] args) { } } 在 interface 内部，我们可以声明属性和方法。其中属性必须使用 public static final 修饰，但其实interface中的属性默认就是 public static final 的，所以可以不写😓；而方法则需要声明为 public abstract，同样的，因为接口中的方法的默认修饰就为 public abstract，所以也可以不写。\n​\t上述是 jdk8 之前的规范，在 jdk8 及以后，接口内可以声明静态方法和默认方法。在 jdk9 及以后，接口内还可以声明私有方法。但我们主要还是使用 public abstract 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public interface Interface { public static final int SIZE = 100; // int SIZE = 100; 这样也是可以的 public abstract void method(); // void method(); OK！ // 默认方法 其中 public 可以省略 但建议保留 public default void method2() { System.out.println(\u0026#34;method2\u0026#34;); } // 静态方法 其中 public 可以省略 但建议保留 public static void method3() { System.out.println(\u0026#34;method3\u0026#34;); } // 静态方法 可以用 static 修饰 // 如果是非 static 就是给接口内部的默认方法调用的 // 如果是 static 就是给接口内部的默认方法和静态方法调用的 private void method4() { System.out.println(\u0026#34;method4\u0026#34;); } // public 可以省略 // 接口也能像类一样 拥有自己的内部接口😋 public interface Inner { } } ​\t说完可以在接口内声明的，还需要提一嘴不能在接口内声明的，构造器、代码块都是不能出现于接口内部的，因为接口并不能被实例化，且接口中没有成员变量需要动态初始化。\n1 2 3 4 5 public interface Interface { Interface() {} // error {} // error static {} // error } 接口的使用 类实现接口 ​\t接口不能创建对象，但是可以被类实现。类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。\n1 2 3 4 5 6 7 8 9 [修饰符] class [class name] implements [interface name] { // [必须] 实现接口中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } [修饰符] class [class name] extends [super class name] implements [interface name] { // [必须] 实现接口中的抽象方法 如果父类也是抽象类也需要实现父类中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } 如果接口的实现类是非抽象类，那么必须重写接口中所有抽象方法。\n默认方法可以选择保留原实现，也可以重写。\n重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了。\n接口中的静态方法和私有方法不能被继承也不能被重写。\n接口的多实现 ​\t在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。所以，一个类能继承一个父类，同时实现多个接口。\n1 2 3 4 5 6 7 8 9 [修饰符] class [class name] implements [interface name1], [interface name2], [interface name3]... { // [必须] 实现接口中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } [修饰符] class [class name] extends [super class name] [interface name1], [interface name2], [interface name3]... { // [必须] 实现接口中的抽象方法 如果父类也是抽象类也需要实现父类中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } ​\t接口中有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface Interface { void method1(); void method2(); } interface Api { void method1(); void method3(); } class Test implements Interface, Api{ @Override public void method1() { // 同时重写了 Interface 和 Api 中的 method1 System.out.println(\u0026#34;method1\u0026#34;); } @Override public void method3() { System.out.println(\u0026#34;method2\u0026#34;); } @Override public void method2() { System.out.println(\u0026#34;method3\u0026#34;); } } ​\t类针对于接口的多实现，在一定程度上弥补了单继承的局限性（只能拿到声明，不能拿到实现）。\n接口的多继承 ​\t一个接口能继承另一个或者多个接口，接口的继承也使用 extends 关键字，子接口会继承父接口的方法。\n​\t一个子类只能有一个父类，但谁说一个子接口只能有一个父接口了😎。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface Interface { void method1(); default void method2(){} } interface Api { static void method3() {} private static void method4() {} } interface Outer extends Interface, Api { default void method5() { method1(); method2(); Api.method3(); // 子接口不能继承父接口的 static 和 private 方法 } } class Test implements Outer { @Override public void method1() { } @Override public void method2() { Outer.super.method2(); } @Override public void method5() { Outer.super.method5(); } } 接口与实现类对象构成多态引用 ​\t实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你 new 的实现类对象实现的方法体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public interface IOut { void goOut(); } class TheRich implements IOut { public void goOut() { System.out.println(\u0026#34;坐飞机头等舱\u0026#34;); } } class ThePoor implements IOut { public void goOut() { System.out.println(\u0026#34;坐快车硬座\u0026#34;); } } class Test { public static void main(String[] args) { IOut theRich = new TheRich(); theRich.goOut(); System.out.println(\u0026#34;--------------------\u0026#34;); IOut thePoor = new ThePoor(); thePoor.goOut(); } } 1 2 3 坐飞机头等舱 -------------------- 坐快车硬座 接口在 jdk8 和 jdk9 中的新特性 使用接口的静态成员 ​\t接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Interface { int NUMBER = 0X1234; static void method(){ System.out.println(\u0026#34;method\u0026#34;); }; } class Test implements Interface{ public static void main(String[] args) { System.out.println(Interface.NUMBER); // OK System.out.println(Test.NUMBER); // OK Interface.method(); // OK Test.method(); // error: static 方法通过其的定义接口调用 不能通过实现类调用 } } 在 Java 中，接口不能继承父接口的 static 方法。这是因为 static 方法属于接口本身，而不是它的实现类或子接口。\nstatic 方法在 Java 接口中只能通过接口名直接调用，不能通过实现类或子接口进行调用。 子接口或实现类不会继承父接口的 static 方法。 这是 Java 的设计决定：static 方法属于定义它的接口，不能通过继承传播。 回忆一下 Java 中的继承对 static 方法的处理方式：\n在 Java 中，子类不能继承父类的 static 方法，但子类可以通过类名直接调用父类的 static 方法。这是因为 static 方法是属于类本身的，而不是属于某个实例或子类。\nstatic 方法属于类，而不是对象：static 方法在类加载时就存在，属于类本身，不依赖于类的实例。 不能通过继承来重写 static 方法：子类不会真正“继承”父类的 static 方法，而是拥有它自己的 static 方法空间。如果子类定义了一个相同名字的 static 方法，这种行为被称为“隐藏”而不是“重写”。 调用方式：static 方法应通过类名调用，即使子类定义了相同的方法，也只能通过类名调用，不应通过实例调用。 使用接口的默认方法 对于接口的静态方法，直接使用接口名进行调用即可，也只能使用接口名进行调用，不能通过实现类的对象进行调用。 对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用，接口不能直接创建对象，只能创建实现类的对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface Interface { // default 可以看作是用来顶替 abstract 的位置的 // 如果什么也不写会默认是 abstract 而 default 就是为了声明该函数不是抽象函数，具有函数体 public default void method1() { System.out.println(\u0026#34;method1\u0026#34;); } default void method2() { System.out.println(\u0026#34;method2\u0026#34;); } default void method3() { // default 函数可以调用其他的default、static、private、private static 方法 method1(); method2(); System.out.println(\u0026#34;method3\u0026#34;); } } class Test implements Interface { @Override public void method1() { // Interface.super.method1(); System.out.println(\u0026#34;Test::method1\u0026#34;); } public static void main(String[] args) { Test test = new Test(); test.method3(); } } 1 2 3 Test::method1 method2 method3 ​\t接口中声明的默认方法可以被实现类继承，实现类在没有重写此方法的情况下，默认调用接口中声明的默认方法。如果实现类重写了此方法，则调用的是自己重写的方法。\n使用接口的私有方法 ​\t接口的私有方法非常简单，你可以简单的认为它是私有的默认方法，但是不能使用 default 关键字。\n1 2 3 4 interface Interface { // 可以带上 static private void method() {} } ​\t私有方法的主要作用就是将静态方法和默认方法中重复出现的代码提取出来，然后进行复用。\njdk8 中相关冲突问题 默认方法冲突 接口冲突 当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？\n无论你多难抉择，最终都是要做出选择的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Interface { default void method() { System.out.println(\u0026#34;Interface method\u0026#34;); } } interface Api { default void method() { System.out.println(\u0026#34;Api method\u0026#34;); } } class Test implements Interface, Api { // error: Test 从类型 Interface 和 Api 继承 method() 的不相关默认值 } ​\t类实现了两个接口，而两个接口定义了同名同参数（相同签名）的默认方法。则实现类在没有重写这两个接口默认方法的条件下，会报错。我们把这个叫做接口冲突。（如果是抽象方法就不会有这个问题，因为抽象方法一定要重写😋）\n1 2 3 4 5 6 7 8 9 10 11 class Test implements Interface, Api { @Override public void method() { // 解决方案1: 保留其中一个父接口的实现 下面二选一 // Interface.super.method(); // Api.super.method(); // 解决方案2: 完全重写 System.out.println(\u0026#34;Test method\u0026#34;); } } ​\t当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？\n​\t当然也是需要重写的了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface Interface { default void method() { System.out.println(\u0026#34;Interface method\u0026#34;); } } interface Api { default void method() { System.out.println(\u0026#34;Api method\u0026#34;); } } interface IProgram extends Interface, Api { @Override default void method() { // Interface.super.method(); // Api.super.method(); System.out.println(\u0026#34;IProgram method\u0026#34;); } } 子接口重写默认方法时，default 关键字必须保留。\n子类重写默认方法时，default 关键字不可以保留。\n类优先原则 ​\t子类（或实现类）继承了父类并实现了接口，并且父类和接口中声明了签名相同的方法。默认的，子类（或实现类）在没有重写此方法的情况下，调用的是父类中的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public interface Interface { default void method1() { System.out.println(\u0026#34;Interface method1\u0026#34;); } void method2(); } class SuperClass { public void method1() { System.out.println(\u0026#34;SuperClass method1\u0026#34;); } public void method2() { System.out.println(\u0026#34;SuperClass method2\u0026#34;); } } class SubClass extends SuperClass implements Interface { public static void main(String[] args) { SubClass subClass = new SubClass(); subClass.method1(); subClass.method2(); System.out.println(\u0026#34;-----------------------------\u0026#34;); new SubClass() { @Override public void method1() { System.out.println(\u0026#34;SubClass method1\u0026#34;); } }.method1(); } } 1 2 3 4 SuperClass method1 SuperClass method2 ----------------------------- SubClass method1 ​\t如果现在我们有一个实现类重写了父类和接口中的签名相同的方法，那么我们如何分别调用实现类自己的、父类的、父接口中的签名相同的方法呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class SubClass extends SuperClass implements Interface { @Override public void method1() { System.out.println(\u0026#34;SubClass method1\u0026#34;); } public void exec() { method1(); // 调用自己的 super.method1(); // 调用父类的 Interface.super.method1(); // 调用父接口的 } public static void main(String[] args) { new SubClass().exec(); } } 1 2 3 SubClass method1 SuperClass method1 Interface method1 常量冲突问题 问题出现的原因：\n当子类既继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。 子类同时实现多个接口，而多个接口存在相同同名常量。 ​\t上述条件只要满足其一，在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class SuperClass { int x = 1;} interface SuperInterface { int x = 2; int y = 2; } interface MotherInterface { int x = 3; } class SubClass extends SuperClass implements SuperInterface, MotherInterface { public void method(){ // System.out.println(\u0026#34;x = \u0026#34; + x);//模糊不清 System.out.println(\u0026#34;super.x = \u0026#34; + super.x); System.out.println(\u0026#34;SuperInterface.x = \u0026#34; + SuperInterface.x); System.out.println(\u0026#34;MotherInterface.x = \u0026#34; + MotherInterface.x); System.out.println(\u0026#34;y = \u0026#34; + y);//没有重名问题，可以直接访问 } public static void main(String[] args) { new SubClass().method(); } } 1 2 3 4 super.x = 1 SuperInterface.x = 2 MotherInterface.x = 3 y = 2 接口的总结与面试题 总结 接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。\n声明接口用 interface ，接口的成员声明有限制：\n① 公共的静态常量\n② 公共的抽象方法\n③ 公共的默认方法 （ JDK8.0 及以上）\n④ 公共的静态方法 （ JDK8.0 及以上）\n⑤ 私有方法 （ JDK9.0 及以上）\n类可以实现接口，关键字是 implements ，并且支持多实现。如果实现类不是抽象类就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（ extends ）在前，实现 （ implements ）在后。\n接口可以继承接口，关键字是 extends ，而且支持多继承。\n接口的默认方法可以选择重写或不重写。如果有冲突问题就需要另行处理。子类重写父接口的默认方法，要去掉 default ，子接口重写父接口的默认方法，不要去掉 default。\n接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过 “ 接口名.静态方法名 ” 进行调用。\n面试题 为什么接口中只能声明公共的静态的常量？\n因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。\n为什么 JDK 8.0 之后允许接口定义静态方法和默认方法呢？它违反了接口作为一个抽象标准定义的概念。\n静态方法：因为之前的标准类库设计中，有很多 Collection / Colletions 或者 Path / Paths 这样成对的接口和类，后面的类中是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对 API，不如把静态方法直接定义到接口中使用和维护更方便。 默认方法：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8 中对 Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。 为什么JDK1.9 要允许接口定义私有方法呢？我们说接口是规范，规范是需要公开让大家遵守的。\n因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。\n接口与抽象类之间的对比 ","date":"2024-10-14T21:50:33+08:00","image":"https://kotoriforest.us.kg/p/1014-%E6%8E%A5%E5%8F%A3interface/cover_hu12441902767145371651.png","permalink":"https://kotoriforest.us.kg/p/1014-%E6%8E%A5%E5%8F%A3interface/","title":"接口interface"}]