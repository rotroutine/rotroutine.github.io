[{"content":"不可变之字符序列String String的特性 java.lang.String 类代表字符串。Java 程序中所有的字符串文字（例如 \u0026quot;hello\u0026quot; ）都可以看作是此类的实例。\n字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。\n字符串 String 类型本身是 final 声明的，意味着我们不能继承 String。\nString 对象的字符内容是存储在一个字符数组 value[] 中的。\u0026quot;abc\u0026quot; 等效于char[] value = {\u0026lsquo;h\u0026rsquo;,\u0026rsquo;e\u0026rsquo;,\u0026rsquo;l\u0026rsquo;,\u0026rsquo;l\u0026rsquo;,\u0026lsquo;o\u0026rsquo;}。\n1 2 3 4 5 6 7 8 9 // jdk8中的部分String源码： public final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { /** The value is used for character storage. */ private final char value[]; // String 对象的字符内容存储在此数组中 /** Cache the hash code for the string */ private int hash; // Default to 0 } private 意味着外面无法直接获取字符数组，而且 String 没有提供 value 的 get 和 set 方法。 final 意味着字符数组的引用不可改变，而且 String 也没有提供方法来修改 value 数组某个元素值。 上述两个条件保证了 String 对象一旦被创建内容就是不可变的。一旦对字符串进行修改，就会产生新对象。 Java 语言提供字符串串联符号 + ，以及将其他类型对象转换为字符串的特殊支持即 toString() 方法。 在 JDK9 中，value 的类型从 char[] 变成了 byte[]\n1 2 3 4 5 6 7 8 9 10 public final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { @Stable private final byte[] value; } // 官方说明： // ... that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused. // 细节： // ... The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used. String的内存结构 直接通过字面量赋值：\n通过 new 创建字符串：\n如图所示String str = new String(\u0026ldquo;Hello\u0026rdquo;)可能同时会创建两个String对象，一个在堆中，一个在字符串常量池中（如果程序之前从未使用过或很久没有使用过\u0026quot;Hello\u0026quot;）。\n字符串常量池的位置：\nJdk1.6及之前： 有永久代，运行时常量池在永久代，运行时常量池包含字符串常量池。 **Jdk1.7：**有永久代，但已经逐步“去永久代”，字符串常量池从永久代里的运行时常量池分离到堆里。 Jdk1.8及之后： 无永久代，运行时常量池在元空间，字符串常量池里依然在堆里。 如果想了解相关内容可以参考：java常量池详解 或 Java 常量池详解（一）字符串常量池\n判断字符串对象是在堆中还是字符串常量池中：\n常量 + 常量：对象在常量池中，且常量池中不会存在相同内容的常量。这里的常量既包括了字面量，也包括了用 final 修饰的常量，后文的常量中也是这个意思。 1 2 3 4 5 6 7 8 9 10 11 // 形式1 字面量 + 字面量 \u0026#34;Hello\u0026#34; + \u0026#34;World\u0026#34;; // 常量池 // 形式2 常量 + 常量 String prefix = \u0026#34;Hello\u0026#34;; String suffix = \u0026#34;World\u0026#34;; prefix + suffix; // 常量池 // 形式3 字面量 + 常量 / 常量 + 字面量 \u0026#34;Hello\u0026#34; + suffix; // 常量池 prefix + \u0026#34;World\u0026#34;; // 常量池 调用intern() 方法得到的对象：在常量池中 1 2 3 String str = new String(\u0026#34;string\u0026#34;); // 堆 str.intern(); // 常量池 \u0026#34;string\u0026#34;.intern(); // 常量池 常量 + 变量 / 变量 + 常量：对象在堆中\nconcat() 方法拼接而成的字符串对象：在堆中。即使是两个常量相拼接也是在堆中，这与 concat() 的实现有关。\n1 2 3 4 5 6 7 public String concat(String str) { if (str.isEmpty()) { return this; } // simpleConcat 底层就是在做拼接 然后将拼接的结果通过 new 返回 return StringConcatHelper.simpleConcat(this, str); } String 的常用 API 构造器 API 描述 public String() 初始化新创建的 String 对象，使其表示空字符序列。 String(String original) 初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。 public String(char[] value) 通过当前参数中的字符数组来构造新的 String。 public String(char[] value,int offset, int count) 通过字符数组的一部分来构造新的 String。 public String(byte[] bytes) 通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String。 public String(byte[] bytes,String charsetName) 通过使用指定的字符集解码当前参数中的字节数组来构造新的 String。指定的字符集只用于解码过程，Java 中所有的字符在内存中都以 Unicode 编码保存，上同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 字面量定义方式：字符串常量对象 String str = \u0026#34;hello\u0026#34;; // 构造器定义方式：无参构造 String str1 = new String(); // 构造器定义方式：创建\u0026#34;hello\u0026#34;字符串常量的副本 String str2 = new String(\u0026#34;hello\u0026#34;); // 构造器定义方式：通过字符数组构造 char chars[] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;}; String str3 = new String(chars); String str4 = new String(chars, 0, 3); // 构造器定义方式：通过字节数组构造 byte bytes[] = {97, 98, 99}; String str5 = new String(bytes); String str6 = new String(bytes,\u0026#34;GBK\u0026#34;); // 以 GBK 编码解码 以 Unicode 编码保存 String与其他结构间的转换 字符串 -\u0026gt; 基本数据类型、包装类：\nInteger 包装类的 public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。 类似地，使用 java.lang 包中的 Byte、Short、Long、Float、Double 类调相应的 parseXxx 方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。 基本数据类型、包装类 -\u0026gt; 字符串：\n调用 String 类的 public String valueOf(int n) 可将 int 型转换为字符串。 相应的 valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b) 可由参数的相应类型到字符串的转换。 也可以通过将数据与空字符串拼接的方式将对应数据转为字符串类型。 字符数组 -\u0026gt; 字符串：\nString 类的构造器：String(char[] value) 和 String(char[] value, int offset, int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。 字符串 -\u0026gt; 字符数组：\npublic char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中并返回该字符数组。\npublic void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)：提供了将指定索引范围内的字符串存放到字符数组中的方法，这个字符数组需要使用者来提供。\n字符串 -\u0026gt; 字节数组（编码）：\npublic byte[] getBytes() ：使用平台的默认字符集将对应 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 public byte[] getBytes(String charsetName) ：使用指定的字符集将对应 String 编码为 byte 序列，并将结果存储到新的 byte 数组。 字节数组 -\u0026gt; 字符串（解码）：\nString(byte[] bytes)：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。 String(byte[] bytes，int offset，int length) ：用指定的字节数组的一部分，即从数组起始位置 offset 开始取 length 个字节使用默认字符集构造一个字符串对象。 String(byte[] bytes, String charsetName) 或 String(byte[] bytes, int offset, int length ,String charsetName)：按照指定的编码方式进行解码。 不乱码的两个条件：\n保证编码和解码的字符集是相同的 解码时对应的字节序列是完整的，没有缺少字节 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void test0() throws Exception { String str = \u0026#34;中国\u0026#34;; System.out.println(str.getBytes(\u0026#34;ISO8859-1\u0026#34;).length); // 2 // ISO8859-1把所有的字符都当做一个byte处理，处理不了多个字节 System.out.println(str.getBytes(\u0026#34;GBK\u0026#34;).length); // 4 每一个中文都是对应2个字节 System.out.println(str.getBytes(\u0026#34;UTF-8\u0026#34;).length); // 6 常规的中文都是3个字节 /* * 不乱码：（1）保证编码与解码的字符集名称一样（2）不缺字节 */ System.out.println(new String(str.getBytes(\u0026#34;ISO8859-1\u0026#34;), \u0026#34;ISO8859-1\u0026#34;)); // 乱码 System.out.println(new String(str.getBytes(\u0026#34;GBK\u0026#34;), \u0026#34;GBK\u0026#34;)); // 中国 System.out.println(new String(str.getBytes(\u0026#34;UTF-8\u0026#34;), \u0026#34;UTF-8\u0026#34;)); // 中国 } 常用方法 方法 描述 boolean isEmpty() 字符串是否为空字符串，不是判断是否为null int length() 返回字符串的长度 String concat(String other) 拼接两个字符串，返回一个新的字符串，原来的字符串保持不变 boolean equals(Object obj) 比较字符串是否相等，区分大小写 boolean equalsIgnoreCase(Object obj) 比较字符串是否相等，不区分大小写 int compareTo(String other) 按照 Unicode 编码值比较字符串大小，区分大小写 int compareToIgnoreCase(String other) 按照 Unicode 编码值比较字符串大小，不区分大小写 String toLowerCase() 将字符串中大写字母转为小写 String toUpperCase() 将字符串中小写字母转为大写 String trim() 去掉字符串前后空白符 public String intern() 返回与当前字符串内容相同的，位于字符串常量池中的字符串的引用 boolean contains(String str) 判断字符串中是否包含 str int indexOf(String str) 从前往后找当前字符串中 str，如果有则返回 str 第一次出现的下标，没有返回则返回 -1 int indexOf(String str, int fromIndex) 从指定索引开始，从前往后找当前字符串中 str，如果有则返回 str 第一次出现的下标，没有返回则返回 -1 int lastIndexOf(String str) 从后往前找当前字符串中 str，如果有则返回 str 第一次出现的下标，没有返回则返回 -1 int lastIndexOf(String str, int fromIndex) 从指定索引开始，从后往前找当前字符串中 str，如果有则返回 str 第一次出现的下标，没有返回则返回 -1 String substring(int beginIndex) 返回一个新的字符串，它是此字符串从 beginIndex 开始截取到最后的一个字符的子字符串 String substring(int beginIndex, int endIndex) 返回一个新的字符串，它是此字符串从 beginIndex 开始截取到 endIndex （不包含）的子字符串。 char charAt(index) 返回字符串 index 位置的字符 char[] toCharArray() 将字符串转换为一个新的字符数组返回 static String valueOf(char[] data) 返回一个新字符串，该字符串用整个 data 数组构建 static String valueOf(char[] data, int offset, int count) 返回一个新字符串，该字符串从 data 数组的 offset 索引开始，使用 count 个字符构建字符串 static String copyValueOf(char[] data) 返回一个新字符串，该字符串用整个 data 数组构建 static String copyValueOf(char[] data, int offset, int count) 返回一个新字符串，该字符串从 data 数组的 offset 索引开始，使用 count 个字符构建字符串 boolean startsWith(String str) 判断字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset) 判断字符串从指定索引开始的子字符串是否以指定前缀开始 boolean endsWith(String str) 判断此字符串是否以指定的后缀结束 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换字符串中出现的所有 oldChar 得到的，不支持正则表达式 String replace(CharSequence target, CharSequence replacement) 使用指定的字面值序列替换字符串所有匹配字面值目标序列的子字符串 String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串 可变之字符序列 StringBuffer、StringBuilder 因为 String 对象是不可变对象，虽然可以共享常量池对象，但是对于频繁的字符串的修改和拼接操作来说，String 的效率极低、空间消耗较高。因此，JDK 又在 java.lang 包提供了可变字符序列 StringBuffer 和 StringBuilder 类型。\njava.lang.StringBuffer 代表可变的字符序列，于JDK1.0中声明，可以对字符串内容进行增删查改操作但不会产生新的对象，而是在原来的字符串中进行操作。比如：\n1 2 3 4 5 6 // 情况1: String s = new String(\u0026#34;我喜欢学习\u0026#34;); // 情况2: StringBuffer buffer = new StringBuffer(\u0026#34;我喜欢学习\u0026#34;); buffer.append(\u0026#34;除了数学\u0026#34;); StringBuilder 和 StringBuffer 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样。\n区分String、StringBuffer、StringBuilder\nString：不可变的字符序列；底层使用 char[] 数组存储数据（JDK8.0中） StringBuffer：可变的字符序列；线程安全（方法有 synchronized 修饰），效率较低；底层使用 char[] 数组存储数据（JDK8.0中） StringBuilder：可变的字符序列； JDK1.5 引入，线程不安全，效率高；底层使用 char[] 数组存储数据（JDK8.0中） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // String、StringBuffer、StringBuilder 的效率测试 @Test public void test() { // 初始设置 final int CIRCLE_SIZE = 100_000; // 循环十万次 long startTime = 0L; long endTime = 0L; String text = \u0026#34;\u0026#34;; StringBuffer buffer = new StringBuffer(\u0026#34;\u0026#34;); StringBuilder builder = new StringBuilder(\u0026#34;\u0026#34;); // 开始对比 startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; CIRCLE_SIZE; i++) { buffer.append(String.valueOf(i)); } endTime = System.currentTimeMillis(); System.out.println(\u0026#34;StringBuffer的执行时间：\u0026#34; + (endTime - startTime) + \u0026#34;ms\u0026#34;); startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; CIRCLE_SIZE; i++) { builder.append(String.valueOf(i)); } endTime = System.currentTimeMillis(); System.out.println(\u0026#34;StringBuilder的执行时间：\u0026#34; + (endTime - startTime) + \u0026#34;ms\u0026#34;); startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; CIRCLE_SIZE; i++) { text = text + i; } endTime = System.currentTimeMillis(); System.out.println(\u0026#34;String的执行时间：\u0026#34; + (endTime - startTime) + \u0026#34;ms\u0026#34;); } 1 2 3 4 // 输出 StringBuffer的执行时间：13ms StringBuilder的执行时间：5ms String的执行时间：2917ms 就执行效率而言：\nStringBuilder \u0026gt; StringBuffer \u0026gt; String\n常用 API StringBuilder、StringBuffer 的 API 是完全一致的，并且很多方法与 String 相同。\nAPI 描述 StringBuffer append(xxx) 提供了很多的 append() 方法，用于进行字符串追加的方式拼接 StringBuffer delete(int start, int end) 删除 [start,end) 之间字符 StringBuffer deleteCharAt(int index) 删除 [index] 位置字符 StringBuffer replace(int start, int end, String str) 替换 [start,end) 范围的字符序列为 str void setCharAt(int index, char c) 替换 [index] 位置字符为 c char charAt(int index) 返回 [index] 位置上的字符 StringBuffer insert(int index, xx) 在 [index] 位置插入 xx int length() 返回存储的字符数据的长度 StringBuffer reverse() 反转字符序列 int indexOf(String str) 在当前字符序列中查询 str 的第一次出现下标 int indexOf(String str, int fromIndex) 在当前字符序列 [fromIndex, 最后] 中查询 str 的第一次出现下标 int lastIndexOf(String str) 在当前字符序列中查询 str 的最后一次出现下标 int lastIndexOf(String str, int fromIndex) 在当前字符序列 [fromIndex, 最后] 中查询 str 的最后一次出现下标 String substring(int start) 截取当前字符序列 [start,最后] String substring(int start, int end) 截取当前字符序列 [start,end) String toString() 返回此序列中数据的字符串表示形式 void setLength(int newLength) 设置当前字符序列长度为 newLength ","date":"2024-11-07T00:17:07+08:00","image":"https://kotoriforest.us.kg/p/1107-string/cover_hu227866813257757490.png","permalink":"https://kotoriforest.us.kg/p/1107-string/","title":"String"},{"content":"相关概念 程序、进程和线程 程序（Program）：为实现特定目标或解决特定问题而用‌计算机语言编写的命令序列的集合。是储存在磁盘上的一个二进制文件，是一个 静态 对象。\n进程（process）：程序的一次执行过程，或是正在内存中运行的 应用程序 。如：运行中的QQ，运行中浏览器。\n进程是操作系统调度和分配资源的最小单位（亦是系统运行程序的基本单位），系统会为每个进程分配不同的内存区域。\n每个进程都有一个独立的内存空间。系统运行一个程序即是一个进程从创建、运行到消亡的过程。（进程的生命周期）\n程序是静态的，进程是动态的。\n现代的 操作系统 大都是支持多进程的，即支持同时运行多个程序。比如我们可以一边使用网易云听歌，一边打开 steam 玩游戏。\n线程：线程也叫做 轻量级进程，是进程中的一个实体也是进程中的一条执行路径，一个进程中至少有一个线程。\n线程是CPU调度和执行的基本单位。 一个进程若可以在同一时间并行或并发执行多个线程，那么该 进程 就是支持多线程的。 一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得 线程间通信 更简便、高效。但多个线程操作共享的系统资源可能会带来安全隐患。 下图红框中的蓝色区域（右侧）为线程独享，黄色区域（左侧）为线程共享。\n不同的进程之间是不共享内存的。所以进程之间数据交换和通信的成本很高。\n区分 操作系统 调度的基本单位和 CPU 调度的基本单位：\n操作系统调度的基本单位是进程：\n进程是一个正在执行的程序的实例，它包括程序代码、数据、状态和资源。操作系统管理进程，并在进程之间切换资源。每个进程独立运行，有自己的地址空间。\n操作系统的调度，广义上涵盖了资源的管理和分配，而不仅限于 CPU 时间。操作系统将 CPU 时间、内存、文件描述符等资源分配给\t各个进程。\nCPU 调度的基本单位是线程：\n线程是一个进程内的执行单元，它拥有自己的寄存器上下文、栈和程序计数器，但与其他线程共享进程的资源。现代操作系统通常\t支持多线程，这允许程序通过多线程实现并行处理。\n线程是比进程更细粒度的执行单位，它代表了程序中一个独立的执行路径。一个进程可以包含多个线程，这些线程共享进程的资源，\t但有独立的执行序列。因此，CPU 调度通常在线程的级别上进行。\n线程调度 分时调度\n所有线程轮流使用 CPU，并且平均分配每个线程占用 CPU 的时间。\n抢占式调度\n​\t让优先级高的线程以 较大的概率 优先使用 CPU。如果线程的优先级相同，那么就会随机选择一个线程进行调度（线程随机性），Java 使用的为抢占式调度。\n多线程程序的优点 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 提高计算机系统 CPU 的利用率。 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。 单核CPU和多核CPU 单核 CPU（单核中央处理器）是指只有一个核心处理器的计算机处理器。‌ 单核 CPU 在工作期间只能执行某一个程序，处理多个程序时只能分时处理。‌\n单核 CPU 在一个时间单元内只能执行一个线程的任务。例如，可以把 CPU 的一个核心看成是医院的一位医生，在一定时间内只能给一个病人诊断治疗。所以单核CPU 的调度执行就是，多个线程在经过一系列的前导操作后（前导操作类似于医院挂号，比如有10个窗口可以进行挂号，允许多人一起执行），然后到CPU 处执行时发现就只有一个核心（对应一个医生），大家必须排队执行。\n这时候想要提升系统性能只有两个办法，要么提升 CPU 性能（让医生看病快点），要么多加几个 CPU 核心或 CPU（多整几个医生）。多核 CPU 是指有两个及以上核心处理器的计算机处理器。\n问：多核 CPU 的效率是单核 CPU 效率的倍数吗？比如在其他条件相同的情况下，四核的处理器的执行效率会是单核的 4 倍吗？\n答：理论上是，但是实际上不可能，因为至少有两方面的约束。\n多个核心共用资源的限制\n譬如，4核 CPU 的核心虽然变成了4倍，但是对应的 内存 、cache、寄存器 并没有同步扩充4倍，此时它们就会限制 CPU 的执行效率（木桶原理）。这就好像医院一样，虽然一个诊室从1个医生变成了4个医生，但是做B超检查的机器还是只有一台，这时诊室的性能瓶颈就从医生转到B超检查了。\n多核之间的协调管理损耗\n譬如，如果多个核心同时运行两个相关的任务，就需要考虑任务的同步（一个任务的进行依赖于另一个任务的结果），这也需要消耗额外的性能。好比公司的运营，一个人的时候不用开会浪费时间，自己跟自己商量就行了。而两个人就要开会同步工作，协调分配，所以工作效率绝对不可能达到2倍。\n并行和并发 并行（parallel）：在 同一时刻 ，有多条指令在一个 CPU 的多个核心 或多个 CPU 上同时执行，此时我们就说这些指令的执行是并行的。比如：多个人同时做不同的事。\n并发（concurrency）：在 一段时间内 ，有多条指令在单个或多个CPU的同一个核心上快速轮换、交替执行，此时我们说这些指令的执行是并发的。并发在宏观上使多个进程具有同时执行的效果。\n并发指的是在一段时间内，宏观上（我们肉眼观察到）有多个程序在同时运行。而单核 CPU 每一时刻只能有一个程序执行，所以微观（实际）上这些程序是分时交替运行的，只不过给人的感觉是在同时运行，因为分时交替运行的时间是非常短的，我们感觉不到线程的切换。\n多核 CPU 则可以将这些程序可以分配到多个核心上分别执行，这样多个程序便可以同时执行，从而实现并发。核越多，并行处理的程序越多，能大大的提高电脑运行的效率。\n就上图来说：\n线程1与线程2在同一时刻由同一个CPU的不同核心执行，它们是并行执行的的。\n在一段时间内，线程1、线程3、与线程4是交替在同一个核心上允许的，它们是并发执行的。同理，线程2与线程5也是并发执行的。\n通过 Java 使用多线程 JVM 允许程序运行多个线程，所有的线程对象都必须是 java.lang.Thread 类或其子类的实例。\n继承 Thread 类 通过继承 Thread 类来 创建 并 启动 多线程的步骤如下：\n定义 Thread 类的子类并重写 run() 方法，每个子类的 run() 方法的方法体就代表了该子类对应线程锁所需要完成的任务。 创建 Thread 子类的实例，即创建线程对象。 调用线程对象的 start() 方法来启动线程。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 自定义线程类 class MyThread extends Thread { // 定义指定线程名称的构造方法 public MyThread(String name) { //调用父类的String参数的构造方法，指定线程的名称 super(name); } // 重写run方法，完成该线程执行的逻辑 @Override public void run() { for (int i = 0; i \u0026lt; 10; i++) { System.out.println(getName() + \u0026#34;：正在执行！\u0026#34; + i); } } } public class Test4 { public static void main(String[] args) { // 创建自定义线程对象1 MyThread mt1 = new MyThread(\u0026#34;子线程1\u0026#34;); // 开启子线程1 mt1.start(); // 创建自定义线程对象2 MyThread mt2 = new MyThread(\u0026#34;子线程2\u0026#34;); // 开启子线程2 mt2.start(); // 在主方法中执行for循环 for (int i = 0; i \u0026lt; 10; i++) { System.out.println(\u0026#34;main线程！\u0026#34; + i); } } } 也可以通过 匿名子类 来进行线程的创建和启动\n1 2 3 4 5 6 7 8 new Thread(\u0026#34;新的线程！\u0026#34;) { @Override public void run() { for (int i = 0; i \u0026lt; 10; i++) { System.out.println(getName() +\u0026#34;：正在执行！\u0026#34;+i); } } }.start(); 实现 Runnable 接口 Java 有单继承的限制，那么当我们无法继承 Thread 类时该如何做呢？核心类库中提供了 Runnable 接口，我们可以实现 Runnable 接口，重写 run() 方法，然后通过 Thread 类的对象代理启动和执行我们重写的 run() 方法。\n通过实现 Runnable 接口来 创建 并 启动 多线程的步骤如下：\n定义 Runnable 接口的实现类，并重写接口的 run() 方法，该 run() 方法的方法体同样是该线程的线程执行体。 创建 Runnable 实现类的实例，并以此实例作为 Thread 类的构造器的 target 参数来创建 Thread 对象，该 Thread 对象才是真正的线程对象。 调用线程对象的 start() 方法，启动线程。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i \u0026lt; 20; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34; \u0026#34; + i); } } } public class Test6 { public static void main(String[] args) { // 创建自定义线程任务对象 MyRunnable mr = new MyRunnable(); // 创建线程对象 Thread t = new Thread(mr, \u0026#34;长江\u0026#34;); t.start(); for (int i = 0; i \u0026lt; 20; i++) { System.out.println(\u0026#34;黄河 \u0026#34; + i); } } } 通过实现 Runnable 接口，使得该类有了线程类的特征。所有的子线程要执行的代码都必须包含在 run() 方法里面。Runnable 接口实现多线程，最终还是通过 Thread 对象的 API 来进行线程控制的。\n同样也可以通过 匿名实现类 来进行线程的创建和启动\n1 2 3 4 5 6 7 8 new Thread(new Runnable() { @Override public void run() { for (int i = 0; i \u0026lt; 10; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34;：\u0026#34; + i); } } }).start(); 对比两种方式 联系：\nThread 类本身也实现了 Runnable 接口\n1 2 3 public class Thread implements Runnable { ... } 区别：\n继承 Thread 类：线程的执行函数为 Thread 子类的 run() 方法。 实现 Runnable 接口：线程的执行函数为 Runnable 实现类的 run() 方法。 实现 Runnable 接口比继承 Thread 类所具有的优势\n避免了单继承的局限性。 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来共享同一份资源。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 使用多线程的注意事项 每个线程都是通过某个特定 Thread 对象的 run() 来执行分配给线程的任务的，因此把 run() 的方法体称为 线程执行体。 通过每个 Thread 对象的 start() 来启动对应线程，而非直接调用 run() 方法。如果直接调用run() 方法，就不会启动一个新线程来执行任务而是由调用 run() 方法的线程来执行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Test { public static void main(String[] args) throws InterruptedException { Thread thread = new TestThread(\u0026#34;子线程\u0026#34;); System.out.printf(\u0026#34;当前的线程数为：%d%n\u0026#34;, Thread.activeCount()); // thread.start(); // 2 子线程 3 thread.run(); // 2 main 2 thread.join(); } } class TestThread extends Thread { public TestThread() { } public TestThread(String name) { super(name); } @Override public void run() { System.out.println(Thread.currentThread().getName()); System.out.printf(\u0026#34;当前的线程数为：%d%n\u0026#34;, Thread.activeCount()); try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } 线程可以嵌套创建，即子线程也可以创建子线程。每一个线程只在逻辑上有父子关系，在实际上是平等的。 1 2 3 4 5 6 7 8 9 10 public class Test { public static void main(String[] args) { new Thread(() -\u0026gt; { System.out.printf(\u0026#34;%s is %s%n\u0026#34;, Thread.currentThread().getName(), \u0026#34;Son Thread\u0026#34;); new Thread(() -\u0026gt; System.out.printf(\u0026#34;%s is %s%n\u0026#34;, Thread.currentThread().getName(), \u0026#34;Grandson Thread\u0026#34;)).start(); }).start(); System.out.println(Thread.currentThread().getName() + \u0026#34; is Main Thread\u0026#34;); } } run() 方法由 JVM 来进行调用，什么时候执行、执行的过程控制都由 CPU 的调度决定。 一个线程对象只能调用一次 start() 启动。如果重复调用了，则将抛出 IllegalThreadStateException。 如果为重写了 run() 方法的 Thread 子类对象传入 Runnable 的实现类对象，会执行 Thread 子类里的 run() 而不是 Runnable 实现类里的 run()。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Test { public static void main(String[] args) { new extendThread(() -\u0026gt; System.out.println(\u0026#34;implementThread::run()\u0026#34;)).start(); } } class extendThread extends Thread { public extendThread() { } public extendThread(Runnable task) { super(task); } @Override public void run() { System.out.println(\u0026#34;extendThread::run()\u0026#34;); } } 上面的代码会输出extendThread::run()。这与 Thread 类 run() 方法的实现有关。\n1 2 3 4 5 6 7 8 9 // Thread::run() @Override public void run() { Runnable task = holder.task; if (task != null) { Object bindings = scopedValueBindings(); runWith(bindings, task); // 调用 Runnable 中的 run() 方法 } } 如果是通过继承 Thread 并重写 run() 方法的方式来创建线程，那么启动线程时调用的就是我们自己重写的 run() 方法，而不会调用Thread 类本身的 run() 方法。如果是通过传入 Runnable 实现类对象的方式来创建线程，那么启动线程时就会通过 Thread 类自己的 run() 方法来调用 Runnable 中的 run() 方法。\n守护线程 有一种线程，它是在后台运行的，它的任务是为其他线程提供服务，这种线程被称为 守护线程。JVM 的垃圾回收线程就是典型的守护线程。\n守护线程有个显著的特点：如果所有非守护线程都死亡，那么守护线程自动死亡。\n调用 setDaemon(true) 方法可将指定线程设置为守护线程。守护线程必须在线程启动之前设置，否则会报 IllegalThreadStateException 异常。\n调用 isDaemon() 可以判断线程是否是守护线程。\nThread 类常用 API 构造器 API 简介 public Thread() 构造一个新的线程对象 public Thread(String name) 构造一个指定名字的新的线程对象 public Thread(Runnable target) 指定创建线程的执行对象，它实现了 Runnable 接口中的 run() 方法 public Thread(Runnable target,String name) 构造一个带有指定执行对象的新线程对象并指定该线程的名字 方法 API 简介 public void run() 线程的执行函数 public void start() 启动线程，由 JVM 来调用 run() 方法 public String getName() 获取当前线程名称 public void setName(String name) 设置该线程名称，在线程启动后也能设置 public static Thread currentThread() 返回执行该方法的线程对象的引用。在Thread 子类中就是 this，通常用于主线程和 Runnable 实现类 public static void sleep(long millis) 使执行该方法的线程阻塞对应毫秒数，在阻塞状态的线程不会参与 CPU 时间片的分配 public static void yield() 提示当前线程让出其当前的 CPU 时间片，使得其他具有相同或更高优先级的线程可以获得执行机会。并不会强制当前线程放弃时间片，其行为依赖于操作系统的线程调度策略。 public static int activeCount() 返回当前正在活跃的线程数 public final boolean isAlive() 测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态 void join() 使执行该方法的线程一直阻塞等待目标线程终止 void join(long millis) 使执行该方法的线程阻塞等待目标线程终止，最多等待 millis 毫秒，如果没等到就停止等待 void join(long millis, int nanos) 使执行该方法的线程阻塞等待目标线程终止，最多等待 millis 毫秒 nanos 纳秒，如果没等到就停止等待 public final void stop() 已过时 强行结束一个线程的执行，使其直接进入死亡状态。run() 立刻停止可能会导致一些清理性的工作得不到完成，如文件、数据库等的关闭。同时，会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。 public final void suspend() public final void resume() 已过时 暂停、恢复线程的执行。这两个操作就好比播放器的暂停和恢复。二者必须成对出现，否则非常容易发生死锁。suspend() 的调用会导致线程暂停，但不会释放任何锁资源，导致其它线程都无法访问被它占用的锁，直到调用 resume()。 public final int getPriority() 返回目标线程的优先级 public final void setPriority(int newPriority) 为目标线程设置优先级，范围在[1,10]之间。线程启动了也能设置 每个线程都有一定的优先级，每个线程默认的优先级都与创建它的父线程具有相同的优先级，其中主线程的优先级为5。\nThread 类的三个优先级常量：\nMAX_PRIORITY（10）：最高优先级 MIN_PRIORITY （1）：最低优先级 NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。 同优先级线程组成先进先出队列（先到先服务），使用分时调度策略。优先级高的线程采用抢占式策略，获得较多的执行机会。\n线程的生命周期 JDK1.5 之前：5种状态 线程的生命周期有五种状态，分别为：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）。CPU 需要在多条线程之间进行调度切换，于是线程状态会多次在运行、阻塞、就绪之间切换。\n新建：\n当一个 Thread 类或其子类的对象被声明并创建时，新生的线程对象处于新建状态。此时它和其他 Java 对象一样，仅仅由 JVM 为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态特征，程序也不会执行它的线程体 run()。\n就绪：\n当线程对象调用了 start() 方法之后，线程就从新建状态转为就绪状态。JVM 会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示已具备了运行的条件，随时可以被调度。至于什么时候被调度，取决于 JVM 里线程调度器的调度。\n运行：\n如果处于就绪状态的线程获得了 CPU 资源，开始执行 run() 方法内的线程体代码，则该线程处于运行状态。如果计算机只有一个 CPU 核心，那么在任何时刻只会有一个线程处于运行状态；如果计算机有多个核心，将会有多个线程并行(Parallel)执行。对于 抢占式策略 的系统而言，系统会给每个可执行的线程一个 时间片 来处理任务，当该时间用完系统就会剥夺该线程所占用的资源，让其回到 就绪状态 等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时系统会适当考虑线程的优先级。\n阻塞：\n当在 运行 过程中的线程遇到如下情况时，会让出 CPU 时间片并保存上下文中止自己的执行，进入 阻塞 状态：\n线程调用了 sleep() 方法，主动放弃所占用的 CPU 资源； 线程试图获取一个同步监视器或锁，但该同步监视器或锁正被其他线程持有； 线程执行过程中，线程调用了 wait()，让它等待通知 notify()； 线程执行过程中，线程调用了 wait(time)，让它在一定时间内等待通知 notify()； 线程执行过程中，需要 join() 等待其他线程死亡。 线程被调用 suspend() 方法被挂起（已过时，因为容易发生死锁）； 当前正在执行的线程被阻塞后，其他线程就有机会执行了。针对如上情况，当发生如下情况时会解除阻塞，让该线程重新进入 就绪 状态，等待线程调度器再次调度它：\n线程的 sleep() 时间到； 线程成功获得了同步监视器或锁； 线程等到了通知 notify()； 线程 wait() 的时间到了 需要 join() 等待的线程结束了； 被挂起的线程被调用了resume() 恢复（已过时，因为容易发生死锁）； 死亡：\n线程会以以下三种方式之一结束，结束后的线程就处于死亡状态：\nrun() 方法执行完成，线程正常结束； 线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error）； 直接调用该线程的 stop() 来结束该线程（已过时） JDK1.5及之后：6种状态 在 java.lang.Thread.State 枚举类中这样定义：\n1 2 3 4 5 6 7 8 public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED; } NEW（新建）：线程刚被创建，但是并未启动。即还没调用start方法。\nRUNNABLE（可运行）：JDK1.5 之后就绪状态和运行状态统一为了可运行状态。因为对于 Java 本身来说最多只能将线程标记为可运行，因为线程什么时候调度运行并不是 JVM 来控制的，而是 OS 来进行决定的，而且调度的时间非常短暂，因此对于 Java 对象的状态来说，无法区分。\nTeminated（终止）：表明此线程已经结束生命周期，终止运行。\n根据 Thread.State 中的定义，阻塞状态被分为三种，分别是：BLOCKED、WAITING 和 TIMED_WAITING。\nBLOCKED（锁阻塞）：在 API 中的介绍为：一个正在阻塞、等待一个监视器锁（锁对象）的线程会处于这一状态。只有获得锁对象的线程才能有执行机会。比如，线程 A 与线程 B 的线程代码中使用同一把锁，如果线程 A 获取到锁，线程 A 进入到 Runnable 状态，而线程 B 就进入到 Blocked 锁阻塞状态。\nTIMED_WAITING（计时等待）：在 API 中的介绍为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。如当前线程执行过程中遇到 Thread 类中的静态方法 sleep 或 join，Object 类中的静态方法 wait 或 LockSupport 类中的 park 方法，并且在调用这些方法时，设置了时间，那么当前线程会进入TIMED_WAITING 状态，直到计时结束，或被提前唤醒中断。\nWAITING（无限等待）：在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。如，当前线程执行过程中遇到遇到 Object 类的 wait，Thread 类的 join，LockSupport 类的 park 方法，并且在调用这些方法时没有指定时间，那么当前线程会进入 WAITING 状态，直到被唤醒。\n通过 Object 类的 wait 方法进入 WAITING 状态的线程需要被 Object 的 notify / notifyAll 方法唤醒； 通过 Condition 的 await 方法进入 WAITING 状态的线程需要被 Condition 的 signal 方法唤醒； 通过 LockSupport 类的 park 方法进入 WAITING 状态的线程需要被 LockSupport 类的 unpark 方法唤醒； 通过 Thread 类的 join 方法进入 WAITING 状态的线程，只有被调用 join 方法的线程对象的生命周期结束才能让当前线程恢复。 当线程从 WAITING 或 TIMED_WAITING 状态恢复到 Runnable 状态时，如果发现当前线程需要但是又没有得到锁时，那么会立刻转入 BLOCKED 状态。\n我们在翻阅 API 的时候会发现 Timed Waiting（计时等待）与 Waiting（无限等待） 状态联系是很紧密的。\n比如进入 waiting（无限等待）状态的 wait 方法是空参的，而进入 timed waiting（计时等待）的 wait 方法是带参的。这种带参的方法是用倒计时来实现计时的操作，相当于我们生活中的小闹钟，如果我们设定好时间，那么它就会到时通知。如果提前得到（唤醒）通知，那么设定的时间就没有存在的必要了（如果你比闹钟叫你还早醒，那么你就可以提前把闹钟关掉了，因为闹钟没有必要再继续倒计时叫你起床了）。这种设计方案其实是一举两得，如果没有得到（唤醒）通知，那么线程就处于 Timed Waiting 状态，直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从 Timed Waiting 状态立刻唤醒，这可以有效的避免某个线程因为没有得到通知而一直处于 Waiting 状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class ThreadStateTest { public static void main(String[] args) throws InterruptedException { SubThread t = new SubThread(); System.out.println(t.getName() + \u0026#34; 状态 \u0026#34; + t.getState()); t.start(); while (Thread.State.TERMINATED != t.getState()) { System.out.println(t.getName() + \u0026#34; 状态 \u0026#34; + t.getState()); Thread.sleep(500); } System.out.println(t.getName() + \u0026#34; 状态 \u0026#34; + t.getState()); } } class SubThread extends Thread { @Override public void run() { while (true) { for (int i = 0; i \u0026lt; 10; i++) { System.out.println(\u0026#34;打印：\u0026#34; + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } break; } } } 使用 jps 命令和 jstack 命令来获取线程的状态：\njps 获取线程 id 需要在线程正在运行的时候才能进行，如果使用 jstack 发出了权限不足的警告，请用管理员模式打开 cmd 或 powershell，具体方式见度娘。\n再推荐一些其他的原生 Java 命令Java常用命令：jps、jstack、jmap、jstat（带有实例教程）。\n线程安全问题及解决 当我们使用多个线程访问同一份资源（可以是同一个变量、同一个文件、同一条记录等）的时候，若多个线程只有读操作，那么就不会发生线程安全问题。但是如果多个线程中既有线程对资源进行读操作，也有线程进行写操作那就 可能会 出现线程安全问题。\n什么样的资源能被或不能被共享 线程方法中的局部变量不能共享 1 2 3 4 5 6 7 8 9 class Window extends Thread { public void run() { int ticket = 100; // 不能共享 while (ticket \u0026gt; 0) { System.out.println(getName() + \u0026#34;卖出一张票，票号:\u0026#34; + ticket); ticket--; } } } 我们可以通过 局部内部类 来共享父线程的局部变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Test { public static void main(String[] args) { final int[] i = {10}; // 对于后面定义的 Runnable 类是可见的 Runnable handler = new Runnable() { @Override public void run() { while (i[0] \u0026gt; 0) { System.out.println(Thread.currentThread().getName() + \u0026#34; i: \u0026#34; + --i[0]); try { Thread.sleep(10); } catch (InterruptedException e) { throw new RuntimeException(e); } } } }; final int[] j = {100}; // 对于前面定义的 Runnable 类是不可见的 Thread t1 = new Thread(handler); Thread t2 = new Thread(handler); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { throw new RuntimeException(e); } } } 局部内部类要想访问外部资源，外部资源必须是 final 的，如果只是读取外部资源就可以不写final，但如果要进行修改就必须用 final 修饰。有关内部类的知识可以参考：Java 内部类\n这种方式需要使用局部内部类或函数式编程，要实现这种方式并不方便，也没什么优点，所以就不推荐这么做了。\n不同对象的实例变量不共享 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class TicketWindow extends Thread { private int ticket = 100; // 如果使用同一个对象，就是共享的；如果使用不同对象，就不是共享的。因为一个 Thread 或其子类 对象不能 start 两次，但 Runnable 实现类能够作为参数传递多次，所以主要用于Runnable中，详见下面 `同一个对象的实例变量共享` public void run() { while (ticket \u0026gt; 0) { System.out.println(getName() + \u0026#34;卖出一张票，票号:\u0026#34; + ticket); ticket--; } } } public class SaleTicketDemo { public static void main(String[] args) { // 下面的线程不共享 ticket TicketWindow w1 = new TicketWindow(); TicketWindow w2 = new TicketWindow(); TicketWindow w3 = new TicketWindow(); } } 同一个类的静态变量是共享的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class TicketWindow extends Thread { private static int ticket = 100; // 同一个类的不同对象可以共享，主要在通过继承 Thread 创建线程时使用 public void run() { while (ticket \u0026gt; 0) { System.out.println(getName() + \u0026#34;卖出一张票，票号:\u0026#34; + ticket); ticket--; } } } public class SaleTicketDemo { public static void main(String[] args) { // 下面的线程共享 ticket TicketWindow w1 = new TicketWindow(); TicketWindow w2 = new TicketWindow(); TicketWindow w3 = new TicketWindow(); } } 同一个对象的实例变量共享 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class TicketSaleRunnable implements Runnable { private int ticket = 100; public void run() { while (ticket \u0026gt; 0) { System.out.println(Thread.currentThread().getName() + \u0026#34;卖出一张票，票号:\u0026#34; + ticket); ticket--; } } } public class SaleTicketDemo { public static void main(String[] args) { TicketSaleRunnable tr = new TicketSaleRunnable(); // 下面的线程共享ticket 因为它们使用了同一个TicketSaleRunnable 对象 // 同理，如果它们使用了不同的 TicketSaleRunnable 对象就是不共享的 Thread t1 = new Thread(tr, \u0026#34;窗口一\u0026#34;); Thread t2 = new Thread(tr, \u0026#34;窗口二\u0026#34;); Thread t3 = new Thread(tr, \u0026#34;窗口三\u0026#34;); t1.start(); t2.start(); t3.start(); } } 共享同一个资源对象（同一个对象的实例变量共享） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // 1、编写资源类 class Ticket { private int ticket = 100; public void sale() { if (ticket \u0026gt; 0) { try { Thread.sleep(10);//加入这个，使得问题暴露的更明显 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \u0026#34;卖出一张票，票号:\u0026#34; + ticket); ticket--; } else { throw new RuntimeException(\u0026#34;没有票了\u0026#34;); } } public int getTicket() { return ticket; } } public class SaleTicketDemo { public static void main(String[] args) { // 2、创建资源对象 Ticket ticket = new Ticket(); // 3、启动多个线程操作资源类的对象 Thread t1 = new Thread(\u0026#34;窗口一\u0026#34;) { public void run() { while (true) { ticket.sale(); } } }; Thread t2 = new Thread(\u0026#34;窗口二\u0026#34;) { public void run() { while (true) { ticket.sale(); } } }; Thread t3 = new Thread(new Runnable() { public void run() { ticket.sale(); } }, \u0026#34;窗口三\u0026#34;); t1.start(); t2.start(); t3.start(); } } 使用同步机制来解决线程安全问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Test { public static void main(String[] args) { Runnable handler = new Runnable() { private int ticket = 100; @Override public void run() { while (ticket \u0026gt; 0) { // 使用 sleep 使问题更容易出现 try { Thread.sleep(100); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(Thread.currentThread().getName() + \u0026#34;:\u0026#34; + ticket--); } } }; new Thread(handler).start(); new Thread(handler).start(); } } 在上述代码中，可能会出现一张票被卖多次或负数票等情况\n要解决上述多线程并发访问同一个资源导致的安全性问题，Java 中提供了同步机制（synchronized）来解决。使用同步机制，在某个线程修改共享资源的时候，其他线程不能访问该资源，只有等待修改完毕同步之后，才能去抢夺CPU 和锁资源完成对应的操作。同步操作保证了数据的同步性，解决了线程不安全的现象。\n注意：在任何时候最多允许一个线程拥有同步锁，谁拿到锁谁就进入代码块，其他的线程只能在外等着（处于 BLOCKED 状态）。\n同步机制解决线程安全问题的原理 同步机制的原理，其实就相当于给某段代码加“锁”，任何线程想要执行这段代码，都要先获得“锁”，我们称它为同步锁。\nJava 对象在堆中的数据分为分为对象头、实例变量、空白的填充（用于内存对齐）。而对象头中包含：\nMark Word：记录了和当前对象有关的GC、锁标记等信息。 指向类的指针：每一个对象需要记录它是由哪个类创建出来的。 数组长度（只有数组对象才有） 哪个线程获得了“同步锁”对象之后，”同步锁“对象就会记录这个线程的ID，这样其他线程就只能等待了，除非这个线程”释放“了锁对象，其他线程才能重新获得 / 占用”同步锁“对象。\n在《Thinking in Java》中是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。\n同步代码块和同步方法 同步代码块：synchronized 关键字可以用于某个区块前面，表示只对这个区块的资源实行互斥访问。\n1 2 3 4 // 示例 synchronized (同步锁对象) { // 需要同步操作的代码 } 同步方法：synchronized 关键字直接修饰方法，表示同一时刻只有一个线程能进入这个方法，其他线程在外面等着。\n1 2 3 4 // 示例 权限修饰符、返回值、函数名、参数列表都可以修改 private synchronized void method(){ // 可能会产生线程安全问题的代码 } 同步锁对象：\n同步锁对象可以是任意类型，但是必须保证竞争“同一个共享资源”的多个线程必须使用同一个“同步锁对象”。\n对于同步代码块来说，同步锁对象是由程序员手动指定的，但很多时候也是指定为 this 或 类名.class(类对象，一个类只会有一个类对象) 。\n但是对于同步方法来说，同步锁对象只能是默认的：\n静态方法：当前类的 Class 对象（类名.class）\n非静态方法：this\n使用同步机制时的思考顺序 如何找问题，即代码是否存在线程安全问题 明确哪些代码是多线程执行的代码 明确多个线程是否有共享数据 明确多线程运行的代码中是否有语句操作共享数据 如何解决 对多条操作共享数据的语句只能同时让一个线程执行，在执行过程中其他线程不可以参与执行。即所有操作共享数据的语句都要放在同步器范围中 注意事项 同步范围太小：不能解决安全问题 同步范围太大：因为一旦某个线程抢到锁其他线程就只能等待（变成单线程），所以如果范围太大就会让原本可以多线程执行的地方也变成单线程执行，这样程序的执行效率就会降低，不能合理利用CPU资源。 代码演示 静态方法加锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class TicketSaleThread extends Thread { private static int ticket = 100; public void run() { //直接锁这里，肯定不行，会导致，只有一个窗口卖票 while (ticket \u0026gt; 0) { saleOneTicket(); } } public synchronized static void saleOneTicket() { //锁对象是TicketSaleThread类的Class对象，而一个类的Class对象在内存中肯定只有一个 if (ticket \u0026gt; 0) { //不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决 System.out.println(Thread.currentThread().getName() + \u0026#34;卖出一张票，票号:\u0026#34; + ticket); ticket--; } } } public class Test { public static void main(String[] args) { TicketSaleThread t1 = new TicketSaleThread(); TicketSaleThread t2 = new TicketSaleThread(); TicketSaleThread t3 = new TicketSaleThread(); t1.setName(\u0026#34;窗口1\u0026#34;); t2.setName(\u0026#34;窗口2\u0026#34;); t3.setName(\u0026#34;窗口3\u0026#34;); t1.start(); t2.start(); t3.start(); } } 非静态方法加锁\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Test { public static void main(String[] args) { TicketSaleRunnable tr = new TicketSaleRunnable(); Thread t1 = new Thread(tr, \u0026#34;窗口一\u0026#34;); Thread t2 = new Thread(tr, \u0026#34;窗口二\u0026#34;); Thread t3 = new Thread(tr, \u0026#34;窗口三\u0026#34;); t1.start(); t2.start(); t3.start(); } } class TicketSaleRunnable implements Runnable { private int ticket = 100; public void run() {//直接锁这里，肯定不行，会导致，只有一个窗口卖票 while (ticket \u0026gt; 0) { saleOneTicket(); } } public synchronized void saleOneTicket() { //锁对象是this，这里就是TicketSaleRunnable对象，因为上面3个线程使用同一个TicketSaleRunnable对象，所以可以 if (ticket \u0026gt; 0) { //不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决 System.out.println(Thread.currentThread().getName() + \u0026#34;卖出一张票，票号:\u0026#34; + ticket); ticket--; } } } 同步代码块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class Test9 { public static void main(String[] args) { // 2、创建资源对象 Ticket ticket = new Ticket(); // 3、启动多个线程操作资源类的对象 Thread t1 = new Thread(\u0026#34;窗口一\u0026#34;) { public void run() { // 不能给 run() 直接加锁，因为t1,t2,t3的三个 run 方法分别属于三个 Thread 类对象， // run 方法是非静态方法，那么锁对象默认选 this，那么锁对象根本不是同一个 所以需要我们自己指定锁对象 while (true) { synchronized (ticket) { ticket.sale(); } } } }; Thread t2 = new Thread(\u0026#34;窗口二\u0026#34;) { public void run() { while (true) { synchronized (ticket) { ticket.sale(); } } } }; Thread t3 = new Thread(new Runnable() { public void run() { while (true) { synchronized (ticket) { ticket.sale(); } } } }, \u0026#34;窗口三\u0026#34;); t1.start(); t2.start(); t3.start(); } } // 1、编写资源类 class Ticket { private int ticket = 1000; public void sale() {//也可以直接给这个方法加锁，锁对象是this，这里就是Ticket对象 if (ticket \u0026gt; 0) { System.out.println(Thread.currentThread().getName() + \u0026#34;卖出一张票，票号:\u0026#34; + ticket); ticket--; } else { throw new RuntimeException(\u0026#34;没有票了\u0026#34;); } } public int getTicket() { return ticket; } } 是否释放锁的操作 任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？\n释放锁的操作 当前线程的同步方法、同步代码块执行结束。\n当前线程在同步代码块、同步方法中遇到 break、return 终止了该代码块、该方法的继续执行。\n当前线程在同步代码块、同步方法中出现了未处理的 Error 或 Exception，导致当前线程异常结束。\n当前线程在同步代码块、同步方法中执行了锁对象的 wait() 方法，当前线程被挂起，并释放锁。\n不会释放锁的操作 线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行。\n线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该该线程挂起，该线程不会释放锁（同步监视器）。\n应尽量避免使用 suspend() 和 resume() 这样的过时的方法来控制线程。 再谈同步 单例模式的线程安全问题 饿汉式没有线程安全问题 饿汉式：在类初始化时就直接创建单例对象，而类初始化过程是没有线程安全问题的，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 形式1 public class HungrySingle { private static final HungrySingle INSTANCE = new HungrySingle(); // 对象是否声明为 final 都可以 private HungrySingle() {} public static HungrySingle getInstance(){ return INSTANCE; } } // 形式2 通过枚举类实现 public enum HungryOne { INSTANCE } 懒汉式有线程安全问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // 形式1 public class LazyOne { private static LazyOne instance; private LazyOne() {} // 方式1：使用同步方法 public static synchronized LazyOne getInstance1() { if (instance == null) { instance = new LazyOne(); } return instance; } // 方式2：使用同步代码块 public static LazyOne getInstance2() { synchronized (LazyOne.class) { if (instance == null) { instance = new LazyOne(); } return instance; } } // 方式3：使用双重判空和同步代码块 只有创造实例才会获取同步锁，其余时候都不会获取锁，能够提升效率 // 一定要双重判空 public static LazyOne getInstance3() { if (instance == null) { synchronized (LazyOne.class) { try { Thread.sleep(10); // 加这个代码，暴露问题 } catch (InterruptedException e) { e.printStackTrace(); } if (instance == null) { instance = new LazyOne(); } } } return instance; } /* 注意： 上述方式3中有指令重排问题 ① mem = allocate(); 为单例对象分配内存空间 ② instance = mem; 将 instance 指向分配的空间，但是空间还没有初始化 ③ ctorSingleton(instance); 为单例对象调用构造器 如果在创建的②③过程中又来了一个线程，此时 instance 已经不是 null 了，但是对象并没有初始化完成。 如果另一个线程返回了这个还未初始化的对象，并且使用了它就会有问题 从 JDK2 开始，分配空间、引用内存空间、调用构造器初始化会在线程的工作存储区一次性完成，然后复制到主存储区。但是需要 volatile 关键字来避免指令重排。 */ } // 形式2 使用内部类 public class LazySingle { private LazySingle() {} public static LazySingle getInstance(){ return Inner.INSTANCE; } private static class Inner{ static final LazySingle INSTANCE = new LazySingle(); } } 内部类只有在外部类被调用才会加载（懒汉式），然后我们通过直接赋值的方式产生 INSTANCE 实例，没有线程安全问题（饿汉式）。\n此模式具有之前两个模式的优点，同时屏蔽了它们的缺点，是最好的单例模式。\n此时的内部类，使用enum进行定义也是可以的。\n死锁 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。\n一旦出现死锁，整个程序既不会发生异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。\n小故事：\n面试官：你能解释清楚什么是死锁，我就录取你！ 面试者：你录取我，我就告诉你什么是死锁！ \u0026hellip;\u0026hellip; 恭喜你，面试通过了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class A { public synchronized void foo(B b) { System.out.println(\u0026#34;当前线程名: \u0026#34; + Thread.currentThread().getName() + \u0026#34; 进入了A实例的foo方法\u0026#34;); // ① try { Thread.sleep(200); } catch (InterruptedException ex) { ex.printStackTrace(); } System.out.println(\u0026#34;当前线程名: \u0026#34; + Thread.currentThread().getName() + \u0026#34; 企图调用B实例的last方法\u0026#34;); // ③ b.last(); } public synchronized void last() { System.out.println(\u0026#34;进入了A类的last方法内部\u0026#34;); } } class B { public synchronized void bar(A a) { System.out.println(\u0026#34;当前线程名: \u0026#34; + Thread.currentThread().getName() + \u0026#34; 进入了B实例的bar方法\u0026#34;); // ② try { Thread.sleep(200); } catch (InterruptedException ex) { ex.printStackTrace(); } System.out.println(\u0026#34;当前线程名: \u0026#34; + Thread.currentThread().getName() + \u0026#34; 企图调用A实例的last方法\u0026#34;); // ④ a.last(); } public synchronized void last() { System.out.println(\u0026#34;进入了B类的last方法内部\u0026#34;); } } public class DeadLock implements Runnable { A a = new A(); B b = new B(); public void init() { Thread.currentThread().setName(\u0026#34;主线程\u0026#34;); // 调用a对象的foo方法 a.foo(b); System.out.println(\u0026#34;进入了主线程之后\u0026#34;); } public void run() { Thread.currentThread().setName(\u0026#34;副线程\u0026#34;); // 调用b对象的bar方法 b.bar(a); System.out.println(\u0026#34;进入了副线程之后\u0026#34;); } public static void main(String[] args) { DeadLock dl = new DeadLock(); new Thread(dl).start(); dl.init(); } } 诱发死锁的原因：\n互斥条件 占用且等待 不可抢夺（或不可抢占） 循环等待 以上4个条件同时出现时就会触发死锁。\n解决死锁：\n诱发死锁需要4个条件同时成立，所以我们只要任意打破其中一个条件就可以了：\n针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题。 针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。 针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。 针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。 Lock 锁 锁是 JDK5.0 的新增功能，用于保证线程的安全。与采用 synchronized 相比，Lock 可提供多种锁方案，更灵活、更强大。Lock 通过显式定义同步锁对象来实现同步。同步锁使用 Lock 对象充当。\njava.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock 对象。\n在实现线程安全的控制中，比较常用的是 ReentrantLock，可以显式加锁、释放锁。ReentrantLock 类实现了 Lock 接口，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。\nLock锁也称同步锁，获取锁与释放锁方法，如下：\npublic void lock()：获取锁 public void unlock() :释放锁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 如果同步代码有异常，要将 unlock() 写入 finally 语句块。 import java.util.concurrent.locks.ReentrantLock; class Window implements Runnable { int ticket = 100; // 1. 创建Lock的实例，必须确保多个线程共享同一个Lock实例 private final ReentrantLock lock = new ReentrantLock(); public void run() { while (true) { try { // 2. 调动lock()，实现需共享的代码的锁定 lock.lock(); if (ticket \u0026gt; 0) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(ticket--); } else { break; } } finally { // 3. 调用unlock()，释放共享代码的锁定 lock.unlock(); } } } } public class ThreadLock { public static void main(String[] args) { Window t = new Window(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); t2.start(); } } Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized 是隐式锁，出了作用域、遇到异常等自动解锁 Lock 只有代码块锁，synchronized 有代码块锁和方法锁 使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且 Lock 具有更好的扩展性（提供更多的子类），更体现面向对象的特性。 Lock 锁可以对读不加锁，对写加锁，synchronized 不可以 Lock 锁可以有多种获取锁的方式，比如可以从 sleep 的线程中抢到锁，而 synchronized 不可以 开发建议中处理线程安全问题优先使用顺序为：\nLock \u0026gt; 同步代码块 \u0026gt; 同步方法\n进程间通信 当我们需要多个线程来共同完成一件任务，并且希望它们按照一定顺序来执行，那么多线程之间就需要一些通信机制来协调它们的工作，以此实现多线程共同操作一份数据。\n比如：线程 A 用来生产包子的，线程 B 用来吃包子的，包子可以理解为同一资源。线程 A 与线程 B 处理的动作，一个是生产，一个是消费，此时 B 线程必须等到 A 线程完成后才能执行，那么线程 A 与线程 B 之间就需要线程通信，即等待唤醒机制。这种有线程生产资源，也有线程消费资源的模式也叫做生产消费者模型。\n等待唤醒机制 等待唤醒机制是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。\n在一个线程满足某个条件时（wait() / wait(time)），就会进入等待状态， 等待其他线程执行完它们的指定代码过后来将其唤醒（notify()）或可以指定 wait 的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 notifyAll() 来唤醒所有的等待线程。wait / notify 就是线程间的一种协作机制。\nwait：线程不再活动，也不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了。这时的线程状态是 WAITING 或 TIMED_WAITING。它要等着别的线程执行一个特别的动作，即“通知（notify）”或者等待时间到。当线程被唤醒后，在对象上等待的线程会从wait set 中释放出来，重新进入到调度队列（ready queue）中\nnotify：选取所通知对象的 wait set 中的一个线程释放\nnotifyAll：释放所通知对象的 wait set 上的全部线程\n注意：\n被通知的线程在唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。\n总结：\n如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态； 否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态 调用 wait 和 notify 需注意的细节 wait 方法与 notify 方法必须要在同步代码块或者是同步函数中使用。因为必须要通过锁对象调用这2个方法。否则会报 java.lang.IllegalMonitorStateException 异常。 wait 方法与 notify 方法必须要由同一个锁对象调用。因为对应的锁对象只能通过 notify 唤醒在自己 wait set 中 wait 的线程。 wait 方法与 notify 方法属于 Object 类。因此锁对象可以是任意对象，因为 Java 中所有的类都是 Object 类的子类。 生产者消费者问题 等待唤醒机制可以解决经典的生产者消费者问题。生产者与消费者问题（producer-consumer problem），也称有限缓冲问题（bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了两个（多个）共享固定大小缓冲区的线程即所谓的“生产者”和“消费者”在实际运行时会发生的问题。\n生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。\n举例：\n生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品。店员一次只能持有固定数量的产品，如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。\n生产者消费者模型中的关键问题：\n线程安全问题：因为生产者与消费者共享数据缓冲区，这可能会产生线程安全问题，不过这个问题可以使用同步解决。 线程的协调工作问题：要解决该问题，就必须让生产者线程在缓冲区满时等待状态（wait）并进入阻塞状态，等到消费者消耗了缓冲区中的数据的时候，再通知（notify）正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待状态（wait）并进入阻塞状态，等到生产者往缓冲区添加数据之后，再通知（notify）正在等待的线程恢复到就绪状态。通过这样的通信机制来解决此类问题。 下面的代码存在一些小问题，仅供参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 public class ProducerAndConsumer { public static void main(String[] args) { Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); Consumer c1 = new Consumer(clerk); Consumer c2 = new Consumer(clerk); p1.setName(\u0026#34;生产者1\u0026#34;); c1.setName(\u0026#34;消费者1\u0026#34;); c2.setName(\u0026#34;消费者2\u0026#34;); p1.start(); c1.start(); c2.start(); } } // 生产者 class Producer extends Thread { private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(\u0026#34;=========生产者开始生产产品========\u0026#34;); while (true) { try { Thread.sleep(40); } catch (InterruptedException e) { e.printStackTrace(); } // 要求clerk去增加产品 clerk.addProduct(); } } } // 消费者 class Consumer extends Thread { private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(\u0026#34;=========消费者开始消费产品========\u0026#34;); while (true) { try { Thread.sleep(90); } catch (InterruptedException e) { e.printStackTrace(); } //要求clerk去减少产品 clerk.minusProduct(); } } } // 资源类 class Clerk { private int productNum = 0;// 产品数量 private static final int MAX_PRODUCT = 20; private static final int MIN_PRODUCT = 0; // 增加产品 public synchronized void addProduct() { if (productNum \u0026lt; MAX_PRODUCT) { productNum++; System.out.println(Thread.currentThread().getName() + \u0026#34;生产了第\u0026#34; + productNum + \u0026#34;个产品\u0026#34;); //唤醒消费者 this.notifyAll(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } // 减少产品 public synchronized void minusProduct() { if (productNum \u0026gt; MIN_PRODUCT) { System.out.println(Thread.currentThread().getName() + \u0026#34;消费了第\u0026#34; + productNum + \u0026#34;个产品\u0026#34;); productNum--; // 唤醒生产者 this.notifyAll(); } else { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } 区分 sleep 和 wait 相同点：\n一旦执行，都会使得当前线程结束执行状态，进入阻塞状态。 不同点：\n定义方法所属的类 sleep() 在 Thread 中定义。 wait() 在 Object 中定义 使用范围 sleep() 可以在任何需要使用的位置被调用 wait() 必须使用在同步代码块或同步方法中 在同步结构中使用，是否会释放同步锁 sleep() 不会释放同步监视器 wait() 会释放同步监视器 结束等待的方式 sleep() 指定时间一到就结束阻塞 wait() 可以指定时间也可以无限等待直到 notify 或 notifyAll 。 JDK5.0 新增创建线程的方式 实现 Callable 接口 与使用 Runnable 相比， Callable 功能更强大\n相比 run() 方法，Callable 中的 call() 方法可以有返回值（需要借助FutureTask类，获取返回结果） 方法可以抛出异常 Future 接口\n可以对 Runnable、Callable 任务的执行进行取消、查询是否完成、获取结果等操作 FutureTask 同时实现了 Runnable 和 Future接口。它既可以作为Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; // 1.创建一个实现Callable的实现类 class NumThread implements Callable { // 2.实现call方法，将此线程需要执行的操作声明在call()中 @Override public Object call() throws Exception { int sum = 0; for (int i = 1; i \u0026lt;= 100; i++) { if (i % 2 == 0) { System.out.println(i); sum += i; } } return sum; } } public class CallableTest { public static void main(String[] args) { // 3.创建Callable接口实现类的对象 NumThread numThread = new NumThread(); // 4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象 FutureTask futureTask = new FutureTask(numThread); // 5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start() new Thread(futureTask).start(); // 接收返回值 try { // 6.获取Callable中call方法的返回值 // get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。 Object sum = futureTask.get(); System.out.println(\u0026#34;总和为：\u0026#34; + sum); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } } 线程池 现有问题：\n如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了。如果需要执行任务就创建线程，任务结束就销毁线程，这样频繁创建和销毁线程就会大大降低系统的效率，因为创建线程和销毁线程都需要时间。\n那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？\n思路：\n提前创建好多个线程放入线程池中，使用时直接获取线程，线程任务执行完毕就将线程放回线程池中。这样就可以避免线程频繁的创建销毁，实现重复利用，能够有效的提高程序的效率。\n线程池的优势：\n提高响应速度（减少了创建新线程和销毁旧线程的时间） 降低资源消耗（重复利用线程池中线程，不需要每次都创建） 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会结束生命周期 \u0026hellip; 线程相关 API：\nJDK5.0 之前，我们必须自定义线程池。从 JDK5.0 开始，Java 内置线程池相关的API。在 java.util.concurrent 包下提供了线程池相关API：ExecutorService 和 Executors。 ExecutorService：真正的线程池接口。常见子类为 ThreadPoolExecutor void execute(Runnable command) ：执行任务 / 命令，没有返回值 Future submit(Callable task)：执行任务，有返回值 void shutdown()：关闭连接池 Executors：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(int nThreads); 创建一个可重用的固定线程数的线程池 Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(int corePoolSize)：创建一个线程池，它主要用来延迟运行任务，或者定期执行任务 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.util.concurrent.*; class NumberThread implements Runnable { @Override public void run() { for (int i = 0; i \u0026lt;= 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + \u0026#34;: \u0026#34; + i); } } } } class NumberThread1 implements Runnable { @Override public void run() { for (int i = 0; i \u0026lt;= 100; i++) { if (i % 2 != 0) { System.out.println(Thread.currentThread().getName() + \u0026#34;: \u0026#34; + i); } } } } class NumberThread2 implements Callable { @Override public Object call() throws Exception { int evenSum = 0;//记录偶数的和 for (int i = 0; i \u0026lt;= 100; i++) { if (i % 2 == 0) { evenSum += i; } } return evenSum; } } public class ThreadPoolTest { public static void main(String[] args) { // 1.提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; //设置线程池的属性 // System.out.println(service.getClass()); // ThreadPoolExecutor service1.setMaximumPoolSize(50); //设置线程池中线程数的上限 // 2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 service.execute(new NumberThread());//适合适用于Runnable service.execute(new NumberThread1());//适合适用于Runnable try { Future future = service.submit(new NumberThread2()); // 适合使用于Callable System.out.println(\u0026#34;总和为：\u0026#34; + future.get()); } catch (Exception e) { e.printStackTrace(); } // 3.关闭连接池 service.shutdown(); } } ","date":"2024-10-29T23:04:11+08:00","image":"https://kotoriforest.us.kg/p/1029-%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/cover_hu13012148811422629911.png","permalink":"https://kotoriforest.us.kg/p/1029-%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"初识多线程"},{"content":"概述 在使用计算机语言进行项目开发的过程中，即使程序员把代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：客户输入数据的格式问题，读取文件是否存在，网络是否始终保持通畅等等。\n异常 ：指的是程序在执行过程中，出现的非正常情况。如果不处理异常最终会导致 JVM 的非正常停止。\n异常指的并不是语法错误和逻辑错误。\n语法错误，编译不会通过，更不会产生字节码文件，程序根本就不能运行。\n代码逻辑错误，只是没有得到想要的结果，例如：求 a 与 b 的和，你写成了 a - b\n异常的抛出机制 Java 中把不同的异常用不同的类表示，一旦发生某种异常，就创建该异常类型的对象，并且抛出（throw）。然后程序员可以捕获 （catch）到这个异常对象并处理；如果没有捕获（catch）这个异常对象，那么这个异常对象将会导致程序终止。\n运行下面的程序，程序会产生一个数组角标越界异常 ArrayIndexOfBoundsException 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class ArrayTools { // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) { int element = arr[index]; return element; } } class ExceptionDemo { public static void main(String[] args) { int[] arr = { 34, 12, 67 }; intnum = ArrayTools.getElement(arr, 4) System.out.println(\u0026#34;num = \u0026#34; + num); System.out.println(\u0026#34; over\u0026#34;); } } 上述程序执行过程图解：\n如何对待异常 对于程序出现的异常，一般有两种解决方法：\n一是遇到错误就终止程序的运行。\n另一种方法是程序员在编写程序时，就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、以及异常的处理，保证代码的健壮性。\nJava 的异常体系 Throwable java.lang.Throwable 类是Java程序执行过程中发生的异常事件对应的类的根父类。\nThrowable中的常用方法：\npublic String getMessage() ：获取发生异常的原因。\npublic void printStackTrace() ：打印异常的详细信息。\n包含了异常的类型、异常的原因、异常出现的位置，由于 printStackTrace 打印的信息中已经包括了 getMessage 中的信息，所以在开发和调试阶段都较推荐使用 printStackTrace 。\nError 和 Exception Throwable 可分为两大类：Error 和 Exception 。分别对应着 java.lang.Error 与 java.lang.Exception 两个类。\nError: JVM 无法解决的严重问题。如：JVM 系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。例如：\nStackOverflowError（栈内存溢出） OutOfMemoryError（堆内存溢出，简称OOM）。 Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行。否则一旦发生异常，程序就会终止。例如：\n空指针访问 试图读取不存在的文件 网络连接中断 数组角标越界 1 2 3 4 5 6 public class Test3 { public static void main(String[] args) { int[] array = new int[10]; System.out.println(array[10]); } } 编译时异常和运行时异常 Java 程序的执行分为编译时过程和运行时过程。有的错误只有在运行时才会发生，比如：除数为0，数组下标越界等。\n因此，根据异常可能出现的阶段，可以将异常分为：\n编译时期异常（即 checked 异常、受检异常）：在代码编译阶段，编译器就能明确 警示 当前代码可能发生（不是一定发生）某个异常，并 明确督促 程序员提前编写处理它的代码。如果程序员没有编写对应的异常处理代码，则编译器就会直接判定编译失败，从而不能生成字节码文件。通常，这类异常的发生不是由程序员的代码引起的，或者不是靠加简单判断就可以避免的，例如：FileNotFoundException（文件找不到异常）、IOException（输入输出异常）、ClassNotFoundException（类找不到异常）。 运行时期异常（即 runtime 异常、unchecked 异常、非受检异常）：在代码编译阶段，编译器完全不做任何检查，无论该异常是否会发生，编译器都不给出任何提示。只有等代码运行起来并确实发生了某个异常，它才能被发现。通常，这类异常是由程序员的代码编写不当引起的，只要稍加判断，或者细心检查就可以避免。 java.lang.RuntimeException 类及它的子类都是运行时异常。比如：ArrayIndexOutOfBoundsException 数组下标越界异常， ClassCastException 类型转换异常、NullPointerException 空指针异常。\n常见错误和异常 Error 最常见的就是 VirtualMachineError ，它有两个经典的子类：StackOverflowError、OutOfMemoryError。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // StackOverflowError public class StackOverflowErrorTest { public static void main(String[] args) { main(args); // 无限递归 main 方法 } } // OutOfMemoryError public class OutOfMemoryErrorTest { public static void main(String[] args) { while (true) { long[] longs = new long[1024 * 1024 * 1024]; // 每一次都申请了 8G 内存 } } } Exception 编译时异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import org.junit.Test; import java.io.File; import java.io.FileInputStream; public class CheckedExceptionTest { @Test public void test1() { Class loadClass = Class.forName(\u0026#34;java.lang.Exception\u0026#34;); // ClassNotFoundException } public void test2() { File file = new File(\u0026#34;D:\\\\Java从入门到提桶跑路.txt\u0026#34;); FileInputStream fis = new FileInputStream(file); // FileNotFoundException int input = fis.read(); // IOException while (input != -1) { System.out.print((char) input); input = fis.read(); // IOException } fis.close(); // IOException } } 运行时异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import org.junit.Test; import java.util.Scanner; public class RuntimeExceptionTest { @Test public void test1(){ int[][] arr = new int[3][]; System.out.println(arr[0].length); // NullPointerException } @Test public void test2(){ Object obj = 15; // 这里执行了自动装箱 String str = (String) obj; // ClassCastException } @Test public void test3(){ int[] arr = new int[5]; for (int i = 1; i \u0026lt;= 5; i++) { System.out.println(arr[i]); // ArrayIndexOutOfBoundsException } } @Test public void test4(){ Scanner input = new Scanner(System.in); System.out.print(\u0026#34;请输入一个整数：\u0026#34;); int num = input.nextInt(); // 这里输入了一个非整数 InputMismatchException input.close(); } @Test public void test5(){ int a = 1; int b = 0; System.out.println(a / b); // ArithmeticException } } 异常的处理 概述 在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行 x / y 运算时，要检测用户输入的是数值还是字符、数据是否为空、分母是否为 0 等。过多的 if-else 分支会导致程序的代码加长、臃肿，可读性差，程序员需要花很大的精力 “堵漏洞” 。因此采用异常处理机制来简化操作。\nJava 采用的异常处理机制，是将需要异常处理的程序代码集中在一起 ，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。\nJava 异常处理有两种方式：\ntry-catch-finally throws + 异常类型 捕获异常（try-catch-finally） Java 提供了异常处理的抓抛模型：\nJava 程序的执行过程中如果出现异常就会生成一个异常类对象，该异常对象将被提交给 Java 运行时系统，这个过程称为抛出（throw）异常。 如果一个方法内抛出异常，该异常对象会被抛给方法调用者来处理。如果异常没有被调用者处理，则异常会继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获（catch）异常。如果一个异常回到 main() 方法，并且 main() 也不处理，则程序会终止运行。 1 2 3 4 5 6 7 8 9 10 11 12 try { ......\t// 可能产生异常的代码 } catch( 异常类型1 e ) { ......\t// 当产生异常类型1异常时的处置措施 } catch( 异常类型2 e ) { ...... // 当产生异常类型2异常时的处置措施 } finally { ...... // 无论是否发生异常，都无条件执行的语句 } try - catch 模型 当某段代码可能发生异常，不管这个异常是编译时异常（受检异常）还是运行时异常（非受检异常），我们都可以使用 try 块将它包围起来，并在 try 块下面编写 catch 分支尝试捕获对应的异常对象。\n捕获异常的第一步是用 try{ … }语句块 选定捕获异常的范围，将可能出现异常的业务逻辑代码放在 try 语句块中。\ncatch 分支分为两个部分，catch() 中编写异常类型和异常参数名，{} 中编写如果发生了这个异常要怎么做的处理代码。\n每个 try 语句块可以伴随一个或多个 catch 语句，用于处理可能产生的不同类型的异常对象。\n如果明确知道产生的是何种异常，可以用该异常类作为 catch 的参数类型，也可以用其父类作为 catch 的参数类型。\n比如：可以用 ArithmeticException 类作为参数的地方，就可以用 RuntimeException 类作为参数，或者用所有异常的父类Exception 类作为参数。但不能是与 ArithmeticException 类无关的异常类型，如 NullPointerException 或自定义的ArithmeticException 的子类，如果是的话 catch 中的语句将不会执行。 如果有多个 catch 分支，并且多个异常类型有父子类关系，必须保证小的子异常类型在上，大的父异常类型在下，否则会编译失败。\ncatch 中常用异常处理的方式：① public String getMessage() ② public void printStackTrace()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public void test() { try { String str = \u0026#34;Hello Java Exception\u0026#34;; str = null; System.out.println(str.charAt(0)); } catch (NullPointerException e) { // 异常的处理方式1 System.out.println(\u0026#34;出现了空指针异常\u0026#34;); } catch (ClassCastException e) { // 异常的处理方式2 System.out.println(\u0026#34;出现了类型转换的异常\u0026#34;); } catch (RuntimeException e) { // 因为运行时异常是上面两个异常的父类 所以要排在它们后面 // 异常的处理方式3 System.out.println(\u0026#34;出现了运行时异常\u0026#34;); } // 此处的代码，在异常被处理了以后，是可以正常执行的 System.out.println(\u0026#34;hello\u0026#34;); } 如果在程序运行时，try 块中的代码没有发生异常，那么 catch 所有的分支都不执行。\n如果在程序运行时，try 块中的代码发生了异常，根据异常对象的类型，将从上到下选择第一个匹配的 catch 分支执行。此时 try 中发生异常的语句下面的代码将不执行，而整个 try\u0026hellip;catch 之后的代码可以继续运行。\n如果在程序运行时，try 块中的代码发生了异常，但是所有 catch 分支都无法匹配（捕获）这个异常，那么 JVM 将会终止当前方法的执行，并把异常对象“抛”给调用者。如果调用者不进行处理，程序就会终止运行。\nfinally 的使用 因为异常会引发程序跳转，从而会导致有些语句执行不到。而程序中有一些特定的代码无论异常是否发生都一定需要执行。例如，数据库连接、输入流输出流、Socket 连接、Lock 锁的关闭等，这样的代码通常就会放到 finally 块中。所以，我们通常将一定要被执行的代码写在 finally 中。\n不论在 try 代码块中是否发生了异常、try 代码块中是否有 return、catch 语句是否执行、catch 中语句是否有异常、catch 语句中是否有 return，finally块中的代码都会被执行。唯一的例外就是使用 System.exit() 来强制终止当前正在运行的 Java 虚拟机，这样的话 finally 中的代码就没有机会执行了。\nfinally 语句和 catch 语句是可选的，不一定要跟在 try 的背后。\n1 2 3 4 5 6 7 8 9 10 11 public void test() { try {} catch (Exception e) {} finally {} try {} catch (Exception e) {} try {} finally {} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 // finally 的使用 // 1.确保资源被关闭 import org.junit.Test; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.util.InputMismatchException; import java.util.Scanner; public class FinallyTest1 { @Test public void test1() { Scanner input = new Scanner(System.in); try { System.out.print(\u0026#34;请输入第一个整数：\u0026#34;); int a = input.nextInt(); System.out.print(\u0026#34;请输入第二个整数：\u0026#34;); int b = input.nextInt(); int result = a / b; System.out.println(a + \u0026#34; / \u0026#34; + b + \u0026#34; = \u0026#34; + result); } catch (InputMismatchException e) { System.out.println(\u0026#34;数字格式不正确，请输入两个整数\u0026#34;); } catch (ArithmeticException e) { System.out.println(\u0026#34;第二个整数不能为0\u0026#34;); } finally { System.out.println(\u0026#34;程序结束，释放资源\u0026#34;); input.close(); } } @Test public void test2() { FileInputStream fis = null; try { File file = new File(\u0026#34;D:\\\\Java从入门到提桶跑路.txt\u0026#34;); fis = new FileInputStream(file); // FileNotFoundException int b = fis.read(); // IOException while (b != -1) { System.out.print((char) b); b = fis.read(); //IOException } } catch (IOException e) { e.printStackTrace(); } finally { try { if (fis != null) fis.close(); // IOException } catch (IOException e) { e.printStackTrace(); } } } } // 2.在 try 中返回 class FinallyTest2 { public static void main(String[] args) { int result = test(\u0026#34;12\u0026#34;); System.out.println(result); /* console: test结束 1 */ } public static int test(String str) { try { Integer.parseInt(str); return 1; } catch (NumberFormatException e) { return -1; } finally { System.out.println(\u0026#34;test结束\u0026#34;); } } } // 3.在 catch 中返回 class FinallyTest3 { public static void main(String[] args) { int result = test(\u0026#34;a\u0026#34;); System.out.println(result); /* console: test结束 -1 */ } public static int test(String str) { try { Integer.parseInt(str); return 1; } catch (NumberFormatException e) { return -1; } finally { System.out.println(\u0026#34;test结束\u0026#34;); } } } // 4.在 finally 中返回 class FinallyTest4 { public static void main(String[] args) { int result = test(\u0026#34;a\u0026#34;); System.out.println(result); /* console: test结束 0 */ } public static int test(String str) { try { Integer.parseInt(str); return 1; } catch (NumberFormatException e) { return -1; } finally { System.out.println(\u0026#34;test结束\u0026#34;); return 0; } } } 如何对待编译期异常和运行时异常 编译期异常：\n如果抛出的异常是 IOException 等编译时异常就必须要捕获，否则就会导致编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常。\n1 2 3 4 5 6 7 8 9 10 11 public class Test { public static void main(String[] args) { try { Class loadClass = Class.forName(\u0026#34;java.lang.Object\u0026#34;); } catch (ClassNotFoundException e) { // throw new RuntimeException(\u0026#34;ClassNotFoundException\u0026#34;); OK 将编译时异常转化为运行时异常 e.printStackTrace(); // OK 直接处理异常 } } } 运行时异常：\n运行时异常的特点是：即使没有使用 try 和 catch 捕获，编译也可以通过（但运行时会发生异常使得程序运行终止）。所以对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。\n声明抛出异常类型（throws） 如果在编写方法体的代码时，某句代码可能发生某个编译时异常，此时不处理这个异常编译不能通过，但是在当前方法体中可能不适合处理或无法给出合理的处理方式，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。\nthrows的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 [修饰符] \u0026lt;返回值类型\u0026gt; \u0026lt;方法名(形参列表)\u0026gt; throws 异常类型1, 异常类型2 ... { // ... } // 抛出编译时异常 public class ThrowsCheckedExceptionTest { public static void main(String[] args) { System.out.println(\u0026#34;上课.....\u0026#34;); try { afterClass(); // 换到这里处理异常 } catch (InterruptedException e) { e.printStackTrace(); System.out.println(\u0026#34;准备提前上课\u0026#34;); } System.out.println(\u0026#34;上课.....\u0026#34;); } public static void afterClass() throws InterruptedException { for (int i = 10; i \u0026gt;= 1; i--) { // sleep()有可能会抛出 InterruptedException 这个编译期异常 Thread.sleep(1000); // 本来应该在这里通过 try-catch 来处理异常 System.out.println(\u0026#34;距离上课还有：\u0026#34; + i + \u0026#34;分钟\u0026#34;); } } } // 抛出运行时异常 import java.util.InputMismatchException; import java.util.Scanner; public class ThrowsCheckedExceptionTest { public static void main(String[] args) { Scanner input = new Scanner(System.in); try { System.out.print(\u0026#34;请输入第一个整数：\u0026#34;); int a = input.nextInt(); System.out.print(\u0026#34;请输入第二个整数：\u0026#34;); int b = input.nextInt(); int result = divide(a, b); System.out.println(a + \u0026#34;/\u0026#34; + b + \u0026#34;=\u0026#34; + result); } catch (ArithmeticException | InputMismatchException e) { e.printStackTrace(); } finally { input.close(); } } public static int divide(int a, int b) throws ArithmeticException { return a / b; } } throws 后面也可以跟运行时异常类型，只是运行时异常类型写或不写对于编译器和程序执行来说几乎没有任何区别。如果写了，唯一的区别就是调用者调用该方法后，使用 try\u0026hellip;catch 结构时，IDEA可以获得更多的信息，提示用户需要添加哪种catch分支。 所以虽然写不写无所谓，但我个人还是推荐写一下的。\nthrows 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class ThrowsCheckedExceptionTest { public static void main(String[] args) { try { method(); } catch (RuntimeException e) { e.printStackTrace(); } } public static void method() throws RuntimeException { int i = 10 / 0; // ArithmeticException int[] array = new int[10]; array[100] = 10; // ArrayIndexOutOfBoundsException } } ArithmeticException 和 ArrayIndexOutOfBoundsException 都是 RuntimeException 的子类，所以通过抛出 RuntimeException 来将这两个异常抛出。\n重写方法时对 throws 的要求 方法重写时对于方法签名是有严格要求的：\n方法名必须相同 形参列表必须相同 返回值类型： 基本数据类型和void：必须相同 引用数据类型：相同或者是被重写方法返回值的子类 权限修饰符：必须大于等于被重写方法的权限，并且要求父类中的被重写方法在子类中是可见的（非private） 不能是static，final修饰的方法 附表：\n权限大小：public \u0026gt; protected \u0026gt; default \u0026gt; private\n修饰符 本类内部 本包内 其他包的子类 其他包非子类 private √ × × × 缺省（default） √ √ × × protected √ √ √ × public √ √ √ √ 此外，对于throws异常列表要求：\n如果父类被重写方法的方法签名后面没有 “ throws 编译时异常类型”，那么重写方法时，方法签名后面也不能出现“ throws 编译时异常类型”。 如果父类被重写方法的方法签名后面有 “ throws 编译时异常类型”，那么重写方法时，throws 的编译时异常类型必须是被重写方法 throws 的编译时异常类型或其子类，或者不 throws 编译时异常（如果重写方法中有编译时异常的话，就用 try-catch 处理掉）。 方法重写，对于“ throws 运行时异常类型”没有要求。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.io.IOException; class Father { public void method() throws Exception { System.out.println(\u0026#34;Father.method\u0026#34;); } } class Son extends Father { @Override public void method() throws IOException, ClassCastException { System.out.println(\u0026#34;Son.method\u0026#34;); } } 两种异常处理方式的选择 前提：对异常使用下面相应的处理方式，此时的异常主要指的是编译时异常，比如运行时异常就不需要满足第二条规则。\n如果程序代码中涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用 try-catch-finally 来处理，保证不出现内存泄漏。 如果父类被重写的方法没有 throws 异常类型，而子类重写的方法中出现异常，则只能考虑使用 try-catch-finally 进行处理，不能 throws。 开发中，如果方法 a 中依次调用了方法 b, c, d 等方法，且方法 b, c, d 之间是递进关系（比如 c 的运行依赖 b 的结果，d 的运行依赖于 c 的结果）。此时，如果方法 b, c, d 中有异常，我们通常选择使用 throws ，而方法 a 中通常选择使用 try-catch-finally 。 1 2 3 4 5 6 7 8 9 10 11 // 运行时异常不满足第二条规则 class Father { public void method() {} } class Son extends Father { @Override public void method() throws RuntimeException { throw new RuntimeException(); } } 手动抛出异常对象（throw） Java 中异常对象的生成有两种方式：\n由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，那么针对当前代码，就会在后台自动创建一个对应异常类的实例对象并抛出。如果深究源码就会发现自动生成的异常对象也是 api 开发者手动抛出的对象，只是相对于我们这些 api 使用者来说是自动的而已。 由开发人员手动创建：new 异常类型([实参列表]); 如果创建好的异常对象不抛出（throw）就不会对程序有任何影响，就像创建一个普通对象一样。但是一旦 throw 抛出，就会对程序运行产生影响了。 1 throw new 异常类名([参数列表]); throw 语句抛出的异常对象，和 JVM 自动创建和抛出的异常对象一样：\n如果是编译时异常类型的对象，同样需要使用 throws 或者 try...catch 处理，否则编译不通过。 如果是运行时异常类型的对象，编译器不做约束。 可以抛出的异常必须是 Throwable 或其子类的实例。下面的语句在编译时将会产生语法错误：\n1 throw new String(\u0026#34;want to throw\u0026#34;); 注意点：\n无论是编译时异常类型的对象，还是运行时异常类型的对象，如果没有被 try..catch 合理的处理，都会导致程序崩溃。\nthrow 语句会导致程序执行流程被改变，throw 语句是明确抛出一个异常对象，因此 throw 下面的代码将不会执行。\n如果当前方法没有 try...catch 处理这个抛出的异常对象，throw 语句就会代替 return 语句提前终止当前方法的执行，并返回一个异常对象给调用者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class ThrowTest { public static void main(String[] args) { try { System.out.println(max(4, 2, 31, 1)); } catch (Exception e) { e.printStackTrace(); } try { System.out.println(max(4)); } catch (Exception e) { e.printStackTrace(); } try { System.out.println(max()); } catch (Exception e) { e.printStackTrace(); } } public static int max(int... nums) { if (nums == null || nums.length == 0) { throw new IllegalArgumentException(\u0026#34;没有传入任何整数，无法获取最大值\u0026#34;); } int max = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; max) { max = nums[i]; } } return max; } } 自定义异常 为什么要自定义异常 Java 中不同的异常类，分别表示着某一种具体的异常情况。那么在开发中总是有些异常情况是核心类库中没有定义好的，此时我们需要根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题，某员工已在团队中等。\n如何自定义异常 继承一个异常类型 自定义一个编译时异常类型：自定义类 extends java.lang.Exception。 自定义一个运行时异常类型：自定义类 extends java.lang.RuntimeException。 提供构造器 建议提供至少两个构造器：一个是无参构造，一个是参数列表为（String message）的构造器。 提供 serialVersionUID 这个 uid 是供对象的序列化和反序列化用的 如果还是不清楚如何自定义异常可以参考 JDK 中的 NullPointerException 是如何继承 RuntimeException 的，当然这只是一个例子，你可以参考异常体系中的任意一对继承关系。\n注意事项 自定义的异常只能通过 throw 抛出。抛出后可以由 try-catch 处理，也可以借助 throws 甩锅给调用者。 自定义异常最重要的是异常类的名字和 message 属性。当异常出现时，可以根据名字判断异常类型。比如：TeamException(\u0026quot;成员已满，无法添加\u0026quot;); 、 TeamException(\u0026quot;该员工已是某团队成员\u0026quot;); 所以在自定义异常类和给手动抛出的异常提供 message时一定要做到见名知意，简洁明白。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.io.Serial; class MyException extends Exception { @Serial private static final long serialVersionUID = 114514415411L; public MyException() { } public MyException(String message) { super(message); } } class MyExceptionTest { public void register(int num) throws MyException { if (num \u0026lt; 0) throw new MyException(\u0026#34;人数为负值，不合理\u0026#34;); else System.out.println(\u0026#34;登记人数\u0026#34; + num); } public void manager() { try { register(100); } catch (MyException e) { System.out.print(\u0026#34;登记失败，出错种类\u0026#34;); } System.out.print(\u0026#34;本次登记操作结束\u0026#34;); } public static void main(String[] args) { MyExceptionTest t = new MyExceptionTest(); t.manager(); } } 小结 异常处理5个关键字：\n类比：上游排污，下游治污。\n小哲理：\n世界上最遥远的距离，是我在 if 里你在 else 里，似乎一直相伴又永远分离；\n世界上最痴心的等待，是我当 case 你是 switch，或许永远都选不上自己；\n世界上最真情的相依，是你在 try 我在 catch 。无论你发神马脾气，我都默默承受，静静处理。到那时，再来期待我们的 finally。\n参考引用 尚硅谷Java零基础全套视频教程(宋红康主讲，java入门自学必备) - 异常处理\n","date":"2024-10-20T16:33:04+08:00","image":"https://kotoriforest.us.kg/p/1020-%E6%9E%9A%E4%B8%BE%E7%B1%BB/cover_hu9013448323673794041.png","permalink":"https://kotoriforest.us.kg/p/1020-%E6%9E%9A%E4%B8%BE%E7%B1%BB/","title":"枚举类"},{"content":" 转载自IDEA中快捷键的使用和修改\n通用快捷键 说明 快捷键 复制代码-copy ctrl + c 粘贴-paste ctrl + v 剪切-cut ctrl + x 撤销-undo ctrl + z 反撤销-redo ctrl + shift + z 保存-save all ctrl + s 全选-select all ctrl + a 提高编写速度 说明 快捷键 智能提示-edit alt + enter 提示代码模板-insert live template ctrl+j 使用xx块环绕-surround with \u0026hellip; ctrl+alt+t 调出生成getter/setter/构造器等结构-generate \u0026hellip; alt+insert 自动生成返回值变量-introduce variable \u0026hellip; ctrl+alt+v 复制指定行的代码-duplicate line or selection ctrl+d 删除指定行的代码-delete line ctrl+y 切换到下一行代码空位-start new line shift + enter 切换到上一行代码空位-start new line before current ctrl +alt+ enter 向上移动代码-move statement up ctrl+shift+↑ 向下移动代码-move statement down ctrl+shift+↓ 向上移动一行-move line up alt+shift+↑ 向下移动一行-move line down alt+shift+↓ 方法的形参列表提醒-parameter info ctrl+p 批量修改指定的变量名、方法名、类名等-rename shift+f6 抽取代码重构方法-extract method \u0026hellip; ctrl+alt+m 重写父类的方法-override methods \u0026hellip; ctrl+o 实现接口的方法-implements methods \u0026hellip; ctrl+i 选中的结构的大小写的切换-toggle case ctrl+shift+u 批量导包-optimize imports ctrl+alt+o 类结构、查找、查看源码 说明 快捷键 如何查看源码-go to class\u0026hellip; ctrl + 选中指定的结构 或 ctrl+b 显示当前类结构，支持搜索指定的方法、属性等-file structure ctrl+f12 退回到前一个编辑的页面-back ctrl+alt+← 进入到下一个编辑的页面-forward ctrl+alt+→ 打开的类文件之间切换-select previous/next tab alt+←/→ 光标选中指定的类，查看继承树结构-Type Hierarchy ctrl+h 查看方法文档-quick documentation ctrl+q 类的UML关系图-show uml popup ctrl+alt+u 生成类的UML关系图 ctrl+shift+alt+u 定位某行-go to line/column ctrl+g 回溯变量或方法的来源-go to implementation(s) ctrl+alt+b 折叠方法实现-collapse all ctrl+shift+ - 展开方法实现-expand all ctrl+shift+ + 查找、替换与关闭 说明 快捷键 查找指定的结构 ctlr+f 快速查找：选中的Word快速定位到下一个-find next ctrl+l 查找与替换-replace ctrl+r 直接定位到当前行的首位-move caret to line start home 直接定位到当前行的末位 -move caret to line end end 查询当前元素在当前文件中的引用，然后按 F3 可以选择 ctrl+f7 全项目搜索文本-find in path \u0026hellip; ctrl+shift+f 关闭当前窗口-close ctrl+f4 调整格式 说明 快捷键 格式化代码-reformat code ctrl+alt+l 使用单行注释-comment with line comment ctrl + / 使用/取消多行注释-comment with block comment ctrl + shift + / 选中数行，整体往后移动-tab tab 选中数行，整体往前移动-prev tab shift + tab DEBUG 说明 快捷键 单步调试（不进入函数内部）- step over F8 单步调试（进入函数内部）- step into F7 强制单步调试（进入函数内部） - force step into alt+shift+f7 选择要进入的函数 - smart step into shift + F7 跳出函数 - step out shift + F8 运行到断点 - run to cursor alt + F9 继续执行，进入下一个断点或执行完程序 - resume program F9 停止 - stop Ctrl+F2 查看断点 - view breakpoints Ctrl+Shift+F8 关闭 - close Ctrl+F4 ","date":"2024-10-18T23:06:05+08:00","image":"https://kotoriforest.us.kg/p/1018-idea%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/cover_hu17497847842243478214.png","permalink":"https://kotoriforest.us.kg/p/1018-idea%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"IDEA中常用的快捷键"},{"content":"概述 为什么需要包装类 Java 提供了两个类型系统，基本数据类型与引用数据类型。使用基本数据类型效率高，然而当要使用只针对对象设计的 API 或新特性（例如泛型），怎么办呢？例如：\n1 2 3 4 5 6 7 8 9 10 // 情况 1：方法形参 Object 类的 equals(Object obj) // 情况 2：方法形参 ArrayList\u0026lt;T\u0026gt; 类的 add(Object obj) // ArrayList\u0026lt;T\u0026gt; 中没有如下的方法： add(int number) add(double d) add(boolean b) // 情况 3：泛型 Set\u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; Cllection\u0026lt;T\u0026gt; Map\u0026lt;K,V\u0026gt; 所以为了使得基本数据类型具备引用数据类型的相关特征（如：封装性、继承性和多态性），Java 为八种基本类型都引入了对应的包装类（封装类）。基本数据类型通过包装类有了类的特点，可以调用类中的方法。\n其中整形和浮点型的包装类继承自 Number，而布尔型和字符型的包装类继承自 Object。\n1 2 3 4 5 6 7 public class Test1 { public static void main(String[] args) { System.out.println(Byte.class.getSuperclass()); System.out.println(Boolean.class.getSuperclass()); System.out.println(Character.class.getSuperclass()); } } 1 2 3 class java.lang.Number class java.lang.Object class java.lang.Object 封装以后的，内存结构对比：\n1 2 3 4 5 6 public class Test1 { public static void main(String[] args) { int num = 520; Integer obj = new Integer(520); } } 自定义包装类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MyInteger { int value; public MyInteger() {} public MyInteger(int value) { this.value = value; } @Override public String toString() { return String.valueOf(value); } } 包装类与基本数据类型间的相互转换 在转换之前，我们先考虑一下为什么需要转换。基本数据类型转包装类的重要性在文章的开头已经提到了。那么我们还需要知道为什么包装类要转成基本数据类型，除了效率的原因外，还因为既然包装类是对象，而在 Java 中对象是不能进行加减乘除等算数运算的（String：幸好我的 + 是拼接的意思，不然我就被开除对象籍了😋），为了能够进行这些运算，就需要将包装类的对象转化为基本数据类型。\n装箱 装箱的意思是：把基本数据类型转为包装类对象。将基本类型转为包装类的对象，是为了使用专门为对象设计的API 和特性。\n装箱就一般来说有两种方法：\n使用包装类的构造器 [推荐] 调用包装类的静态工厂方法valueOf() 因为包装类的构造器在 JDK9 遭到废弃，所以不是很推荐用第一种方法来构建包装类了。\n1 2 3 4 5 6 7 // 使用构造函数函数 Integer obj1 = new Integer(4); // 参数为对应类型变量 Float f = new Float(“4.56”); // 参数为字符串 Long l = new Long(“asdf”); // 抛出异常 NumberFormatException // 使用包装类中的 valueOf 方法 Integer obj2 = Integer.valueOf(4); 说到装箱就不得不提一嘴 Boolean 的装箱了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Test1 { public static void main(String[] args) { Boolean b1 = new Boolean(true); // true Boolean b2 = new Boolean(\u0026#34;true\u0026#34;); // true Boolean b3 = Boolean.TRUE; // true Boolean b4 = Boolean.valueOf(true); // true Boolean b5 = new Boolean(\u0026#34;TrUe\u0026#34;); // true 使用字符串构建时会忽略大小写 Boolean b6 = Boolean.valueOf(\u0026#34;TRUE\u0026#34;); // 这里会抛出异常吗？ Boolean b7 = new Boolean(\u0026#34;1234567\u0026#34;); Boolean b8 = Boolean.valueOf(\u0026#34;abcdefg\u0026#34;); // 这里使用了 JDK5 的自动插装箱特性 之后再说 System.out.println(\u0026#34;b1 = \u0026#34; + b1); System.out.println(\u0026#34;b2 = \u0026#34; + b2); System.out.println(\u0026#34;b3 = \u0026#34; + b3); System.out.println(\u0026#34;b4 = \u0026#34; + b4); System.out.println(\u0026#34;b5 = \u0026#34; + b5); System.out.println(\u0026#34;b6 = \u0026#34; + b6); System.out.println(\u0026#34;b7 = \u0026#34; + b7); System.out.println(\u0026#34;b8 = \u0026#34; + b8); } } 你可能以为用 1234567 和 abcdefg 也会抛出异常，但很可惜，它并不会，而是被赋值为false。\n1 2 3 4 5 6 7 8 b1 = true b2 = true b3 = true b4 = true b5 = true b6 = true b7 = false b8 = false 这是为什么呢？让我们看看源码就知道了\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Deprecated(since=\u0026#34;9\u0026#34;, forRemoval = true) public Boolean(String s) { this(parseBoolean(s)); } public static Boolean valueOf(String s) { return parseBoolean(s) ? TRUE : FALSE; } // 我们发现它们都调用了 parseBoolean 这个方法，那么奥秘一定在其中 public static boolean parseBoolean(String s) { return \u0026#34;true\u0026#34;.equalsIgnoreCase(s); } 看过源码后我们就发现了，用字符串给Boolean赋值的原理是用传入的字符串与 `true` 做忽略大小写的比较，然后用比较出来的结果来赋值，通过源码我们不仅知道了只要传入的字符串不是 true 及其大小写变形得到的结果就是 false ，还知道了为什么用字符串构建会忽略大小写，原因是调用了字符串的 equalsIgnoreCase 方法。\n拆箱 拆箱就是把包装类对象拆为基本数据类型。将包装类对象转为基本数据类型一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的，如比较、算术等。\n拆箱就非常简单了，只需要调用对应包装类的 xxxValue() 方法就可以了。\n1 2 3 4 5 6 7 8 9 10 11 public class Test1 { public static void main(String[] args) { int i = Integer.valueOf(1).intValue(); boolean b = Boolean.valueOf(\u0026#34;TUre\u0026#34;).booleanValue(); double d = Double.valueOf(114514.0).doubleValue(); System.out.println(\u0026#34;i = \u0026#34; + i); System.out.println(\u0026#34;b = \u0026#34; + b); System.out.println(\u0026#34;d = \u0026#34; + d); } } 1 2 3 i = 1 b = false d = 114514.0 自动拆装箱 由于我们经常要做基本类型与包装类之间的转换，从 JDK5.0 开始，基本类型与包装类的装箱、拆箱动作可以自动完成。\n1 2 3 4 5 Integer i = 4; //自动装箱 相当于 Integer i = Integer.valueOf(4) // 等号右边: 将 i 对象转成基本数值(自动拆箱)，相当于 i.intValue() + 5 // 等号左边: 加法运算完成后，再次装箱，把基本数值转成对象。i = Integer.valueOf(i.intValue() + 5) i = i + 5; 注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。\n1 2 Integer i = 1; Double d = 1; //错误的，1 是 int 类型 自动装箱和自动拆箱并不是什么高大上的东西，只是隐式帮我们调用了 valueOf() 和 xxxValue()方法而已。\n1 2 3 4 5 6 public class Test1 { public static void main(String[] args) { Integer ii = 4; int i = ii; } } 包装类对象的特点及注意事项 包装类缓存对象 为了引入这个特点，我们先看一个题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test2 { public static void main(String[] args) { Integer i1 = 1; Integer i2 = Integer.valueOf(1); Integer i3 = new Integer(1); System.out.println(i1 == i2); // true System.out.println(i1 == i3); // false Integer i4 = 114514; Integer i5 = Integer.valueOf(114514); Integer i6 = new Integer(114514); System.out.println(i4 == i5); // false System.out.println(i4 == i6); // false } } 我们知道对象之间的 == 是在比较对象的地址值，i1 和 i2 相等，说明 i1 和 i2 其实是同一个对象，而 i1 与 new 出来的 i3 不是同一个对象，结合上文我们说过自动装箱其实是调用了 valueOf() 方法，那是不是可以得出一个结论，通过 valueOf 得到的其实都是同一个对象呢？这个想法其实很接近真正的答案，不过先再让我们看看 i4 和 i5，我们发现 i4 和 i5 这两个valueOf 得到的对象又不是同一个了。为了解决这个问题，让我们来看看 valueOf 的源码。\n1 2 3 4 5 6 @IntrinsicCandidate public static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 我们又发现 valueOf 内部借助了一个 IntegerCache 类，那么奥妙肯定就在其中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 private static final class IntegerCache { static final int low = -128; static final int high; @Stable static final Integer[] cache; static Integer[] archivedCache; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;); if (integerCacheHighPropValue != null) { try { h = Math.max(parseInt(integerCacheHighPropValue), 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(h, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; // Load IntegerCache.archivedCache from archive, if possible CDS.initializeFromArchive(IntegerCache.class); int size = (high - low) + 1; // Use the archived cache if it exists and is large enough if (archivedCache == null || size \u0026gt; archivedCache.length) { Integer[] c = new Integer[size]; int j = low; for(int i = 0; i \u0026lt; c.length; i++) { c[i] = new Integer(j++); } archivedCache = c; } cache = archivedCache; // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } private IntegerCache() {} } 对于这份源码我们不需要完全看懂（我才不会告诉你我也没看多少呢😎），把这份代码精简一下大概就是这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private static final class IntegerCache { static final int low = -128; static final int high; @Stable static final Integer[] cache; static Integer[] archivedCache; static { int h = 127; high = h; int size = (high - low) + 1; // size = 256 if (archivedCache == null || size \u0026gt; archivedCache.length) { Integer[] c = new Integer[size]; int j = low; for(int i = 0; i \u0026lt; c.length; i++) { // 循环 size 次 c[i] = new Integer(j++); // c = {low, low + 1, ..., high - 1, high} 即 [-128, 127] } archivedCache = c; } cache = archivedCache; // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } private IntegerCache() {} } 这份代码是我断章取义的结果，只能用来大概理解，如有错误还请体谅并指正。\n总而言之，就是 IntegerCache 类中定义了一个长度为256的数组，其中存放了 [-128, 127] 对应的 Integer 对象，结合 valueOf() 方法就能得出：如果你通过 valueOf (或者自动包装)得到的 Integer 包装类对象所对应的值在[-128, 127]之间，那么就不会给你创建新对象，而是从 cache 数组中去取来给你用。。这也是为什么包装类要废弃构造函数，推荐使用valueOf 的原因，因为它可以通过 cache 数组来减少对象的创建，提升效率，而通过构造器 new 出来的对象是实打实创建了一个新的出来。\n1 2 3 4 5 6 7 8 9 10 /** * It is rarely appropriate to use this constructor. The static factory * {@link #valueOf(int)} is generally a better choice, as it is * likely to yield significantly better space and time performance. * 很少适合使用此构造函数。静态工厂 {@link valueOf（int）} 通常是更好的选择，因为它可能会产生明显更好的空间和时间性能。 */ @Deprecated(since=\u0026#34;9\u0026#34;, forRemoval = true) public Integer(int value) { this.value = value; } 当然了，不只 Integer 有缓存数组，很多包装类也有：\n包装类 缓存对象 Byte -128 ~ 127 Short -128 ~ 127 Integer -128 ~ 127 Long -128 ~ 127 Float 无 Double 无 Character 0 ~ 127 Boolean true 和 false 包装类对象不可变 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Test3 { public static void main(String[] args) { int i = 1; Integer j = new Integer(2); Circle c = new Circle(); change(i, j, c); System.out.println(\u0026#34;i = \u0026#34; + i); // 1 System.out.println(\u0026#34;j = \u0026#34; + j); // 2 System.out.println(\u0026#34;c.radius = \u0026#34; + c.radius); // 10.0 } /* * 方法的参数传递机制： * （1）基本数据类型：形参的修改完全不影响实参 * （2）引用数据类型：通过形参修改对象的属性值，会影响实参的属性值 * 这类 Integer 等包装类对象是“不可变”对象，即一旦修改，就是新对象，和实参就无关了 */ public static void change(int a, Integer b, Circle c) { a += 10; Integer tmp = Integer.valueOf(b + 10); b += 10; // 等价于 b = Integer.valueOf(b + 10); System.out.println(b == tmp); // true c.radius += 10; } } class Circle { double radius; } b 的运算顺序为：先拆箱，把拆箱得到的数据与10相加，把相加得到的数作为 valueOf 的形参创建一个新的 Integer 对象。\n包装类与基本数据类型的默认值不同 我们在声明类的成员变量变量的时候，可能会声明包装类对象而不是基本数据类型。这时我们就要注意到，包装类是引用数据类型，所以它的默认值相对于基本数据类型发生了变化。\n1 2 3 4 5 6 7 8 9 10 public class Test1 { Integer integer; int i; public static void main(String[] args) { Test1 t = new Test1(); System.out.println(t.i); // 0 System.out.println(t.integer); // null } } 所以在使用时要注意一下它们类型变化带来的差异。\n类型转化问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test4 { public static void main(String[] args) { Integer i1 = 1000; double j1 = 1000; // true 会先将 i 自动拆箱为 int，然后根据基本数据类型“自动类型转换”规则，转为 double 进行比较 System.out.println(i1 == j1); Integer i2 = 1000; int j2 = 1000; System.out.println(i2 == j2); // true 会自动拆箱，按照基本数据类型进行比较 Integer i3 = 1; Double d3 = 1.0; System.out.println(i3 == d3); // 编译报错 Integer 与 Double 不能进行比较，其他包装类也是一样的 } } 字符串与基本数据类型的转化 基本数据类型转字符串 1 2 3 4 5 6 7 8 // 方法1 调用字符串重载的 valueOf() 方法 int a = 10; // String str = a; error String str = String.valueOf(a); // ok // 方法2 与空字符串进行拼接 int a = 10; String str = a + \u0026#34;\u0026#34;; // ok 字符串转基本类型 除了 Character 类之外，其他所有包装类都具有 parseXxx 静态方法可以将字符串参数转换为对应的基本类型。 public static int parseInt(String s)：将字符串参数转换为对应的 int 基本类型。 public static long parseLong(String s)：将字符串参数转换为对应的 long 基本类型。 public static double parseDouble(String s)：将字符串参数转换为对应的 double 基本类型。 字符串转为包装类，然后可以自动拆箱为基本数据类型。 public static Integer valueOf(String s)：将字符串参数转换为对应的 Integer 包装类，然后可以自动拆箱为 int 基本类型。 public static Long valueOf(String s)：将字符串参数转换为对应的 Long 包装类，然后可以自动拆箱为 long 基本类型。 public static Double valueOf(String s)：将字符串参数转换为对应的 Double 包装类，然后可以自动拆箱为 double 基本类型。 注意: 如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出 java.lang.NumberFormatException 异常。 1 2 3 4 5 6 7 8 9 10 // 方法1 int a = Integer.parseInt(\u0026#34;整数的字符串\u0026#34;); double d = Double.parseDouble(\u0026#34;小数的字符串\u0026#34;); boolean b = Boolean.parseBoolean(\u0026#34;true 或 false\u0026#34;); // 方法2 int i = new Integer(“12”); int a = Integer.valueOf(\u0026#34;整数的字符串\u0026#34;); double d = Double.valueOf(\u0026#34;小数的字符串\u0026#34;); boolean b = Boolean.valueOf(\u0026#34;true 或 false\u0026#34;); ","date":"2024-10-18T17:29:55+08:00","image":"https://kotoriforest.us.kg/p/1018-%E5%8C%85%E8%A3%85%E7%B1%BB/cover_hu14133844856861668868.png","permalink":"https://kotoriforest.us.kg/p/1018-%E5%8C%85%E8%A3%85%E7%B1%BB/","title":"包装类"},{"content":"下载并加载 jar 包 这里我们使用的是 JUnit4，首先我们先进入官网，然后拉到下方点击红框中的内容。\n我们先进入 ① 下载\n然后再进入 ② 下载\n如果你没有办法进入GitHub，你可以选择下载一个 Steam++，它提供免费的Github加速功能。或者直接下载我下好的jar包。\n下载完毕之后，你可以把 jar 包随便放在一个地方，但是我推荐新建一个文件夹。然后把所有的 jar 包都放在一起，这样可以方便管理。\n然后按下图导入 JUnit 库\n这里可以选择单独选择 jar 包，也可以选择一个文件夹，IDEA 会自动读取文件夹下 jar 包，这也是我推荐新建一个文件夹来存放 jar 包的原因。\n然后选择要使用这个库的模块，这样的话，被选择的模块就可以使用 JUnit 了。\n如果你还想在其他模块使用 JUnit\n然后选择 JUnit 所对应的库就可以了。\n有一点需要注意的是，在添加成功后，一定要把作用改为编译，否则在编译时就无法使用 JUnit。 使用 JUnit 如何使用我就不具体细说了，可以自己参考官方文档，我这里就提一点细节。\n@Test的使用条件 JUnit4版本，要求@Test标记的方法必须满足如下要求：\n所在的类必须是 public 的，非抽象的，包含唯一的无参构造器。 @Test 标记的方法本身必须是 public ，非抽象的，非静态的 void 无返回值， 无参数的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class JUnitTest { @Test public void test01() { System.out.println(\u0026#34;TestJUnit.test01\u0026#34;); } @Test public void test02() { System.out.println(\u0026#34;TestJUnit.test02\u0026#34;); } @Test public void test03() { System.out.println(\u0026#34;TestJUnit.test03\u0026#34;); } } @Test 修饰的方法在行号旁会有一个小箭头，点击那个小箭头就可以单独运行这个方法。\n让单元测试支持控制台输入 默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入（会提示此视图只读）。需要做如下设置：\n在 idea64.exe.vmoptions 配置文件中加入下面一行设置\n-Deditable.java.test.console=true\n然后重启 IDEA 就可以生效了。\n","date":"2024-10-18T12:21:54+08:00","image":"https://kotoriforest.us.kg/p/1018-%E5%9C%A8idea%E4%B8%AD%E4%BD%BF%E7%94%A8junit/cover_hu16502903383969207758.png","permalink":"https://kotoriforest.us.kg/p/1018-%E5%9C%A8idea%E4%B8%AD%E4%BD%BF%E7%94%A8junit/","title":"在IDEA中使用JUnit"},{"content":"枚举 概述 枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建。\n在生活中枚举的例子数不胜数：\n星期：Monday（星期一 ）…… Sunday（星期天） 性别：Man（男） 、 Woman（女） 月份：January（1 月）\u0026hellip;\u0026hellip; December（12 月） 等等 在开发中，如果针对于某个类而言，其实例的个数是确定的，那么这个类就可以声明为枚举类，也推荐声明为枚举类。并且如果这个枚举类的实例就只有一个，就可以把这个枚举类看作是单例实现的。\n在 JDK5.0 之前，需要程序员自定义枚举类型。在 JDK5.0 之后， Java 支持 通过 enum 关键字来快速定义枚举类型。\n枚举类的使用 定义枚举类 JDK 5.0 之前 在JDK5.0 之前如何声明枚举类呢？\n私有化类的构造器，保证不能在类的外部创建其对象。 在类的内部创建枚举类的实例。声明为：public static final，对外暴露这些常量对象。 类中如果有实例变量，应该声明为 private final（建议，不是必须），并在构造器中初始化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Season { private final String SEASON_NAME; //季节的名称 private final String SEASON_DESC; //季节的描述 private Season(String seasonName, String seasonDesc) { this.SEASON_NAME = seasonName; this.SEASON_DESC = seasonDesc; } // Season 的实例 都是静态的 可以通过类名获得 // 实例都是 final 的 防止被用户在外部改变 如：Season.SPRING = null; // 可以写在类中的任意位置 public static final Season SPRING = new Season(\u0026#34;春天\u0026#34;, \u0026#34;春暖花开\u0026#34;); public static final Season SUMMER = new Season(\u0026#34;夏天\u0026#34;, \u0026#34;夏日炎炎\u0026#34;); public static final Season AUTUMN = new Season(\u0026#34;秋天\u0026#34;, \u0026#34;秋高气爽\u0026#34;); public static final Season WINTER = new Season(\u0026#34;冬天\u0026#34;, \u0026#34;白雪皑皑\u0026#34;); @Override public String toString() { return \u0026#34;Season{\u0026#34; + \u0026#34;SEASON_NAME=\u0026#39;\u0026#34; + SEASON_NAME + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, SEASON_DESC=\u0026#39;\u0026#34; + SEASON_DESC + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } class SeasonTest { public static void main(String[] args) { System.out.println(Season.SPRING); System.out.println(Season.SUMMER); System.out.println(Season.AUTUMN); System.out.println(Season.WINTER); } } 1 2 3 4 Season{SEASON_NAME=\u0026#39;春天\u0026#39;, SEASON_DESC=\u0026#39;春暖花开\u0026#39;} Season{SEASON_NAME=\u0026#39;夏天\u0026#39;, SEASON_DESC=\u0026#39;夏日炎炎\u0026#39;} Season{SEASON_NAME=\u0026#39;秋天\u0026#39;, SEASON_DESC=\u0026#39;秋高气爽\u0026#39;} Season{SEASON_NAME=\u0026#39;冬天\u0026#39;, SEASON_DESC=\u0026#39;白雪皑皑\u0026#39;} JDK 5.0 之后 在 JDK 5.0 之后，定义枚举类就非常方便了\n1 2 3 4 5 6 // []中的内容表示可选 // \u0026lt;\u0026gt;中的内容表示必选 [public] enum \u0026lt;enum name\u0026gt; { 常量对象列表; (不同对象之间用\u0026#39;,\u0026#39;连接， 最后以\u0026#39;;\u0026#39;结尾) [对象的实例变量列表]; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 举例 public enum Season { // 定义枚举实例必须这么写 不能添加额外的东西 public static final 也不行！ // 必须在枚举类的最上面 既常量列表的上面不能有其他语句 SPRING(\u0026#34;春暖花开\u0026#34;), SUMMER(\u0026#34;夏日炎炎\u0026#34;), AUTUMN(\u0026#34;秋高气爽\u0026#34;), WINTER(\u0026#34;白雪皑皑\u0026#34;); private final String SEASON_DESC; //季节的描述 // 这里的 private 可以省略 private Season(String seasonDesc) { this.SEASON_DESC = seasonDesc; } } 如果枚举类中没有实例变量，那么定义出来枚举类就可以变成短短的一行\n1 2 3 public enum Week { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; } enum定义的要求和特定：\n枚举类的常量对象列表必须在枚举类的首行。因为是常量，所以建议大写。 列出的实例系统会自动添加 public static final 修饰。不需要也不能手动添加。 如果常量对象列表后面没有其他代码，那么 \u0026rsquo;;\u0026rsquo; 可以省略，否则不可以省略。 编译器给枚举类默认提供的是 private 的无参构造器，如果枚举类需要的是无参构造器就不需要声明，写常量对象列表时也不用加括号和参数。 如果枚举类需要的是有参构造器就需要手动定义，有参构造器的 private 修饰符可以省略，调用有参构造器的方法就是在常量对象名后面加括号和实参列表就可以。 枚举类可以作为枚举类和其他类的内部类。 枚举类默认继承的是 java.lang.Enum 类，因此不能再继承其他的类型。但是枚举类可以实现接口。 JDK5.0 之后 switch 支持枚举类型， case 后面可以写枚举常量名，无需添加枚举类作为限定（当然加了也不会错）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 interface IWeek { void showWeek(); } public enum Week implements IWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; @Override public void showWeek() { System.out.println(\u0026#34;Week::showWeek()\u0026#34;); } } class TestWeek { public static void main(String[] args) { Week week = Week.MONDAY; System.out.println(week.getClass()); System.out.println(week.getClass().getSuperclass()); System.out.println(week.getClass().getSuperclass().getSuperclass()); switch (week) { case Week.MONDAY: System.out.println(\u0026#34;MONDAY\u0026#34;); break; case TUESDAY: System.out.println(\u0026#34;TUESDAY\u0026#34;); break; case WEDNESDAY: System.out.println(\u0026#34;WEDNESDAY\u0026#34;); break; case THURSDAY: System.out.println(\u0026#34;THURSDAY\u0026#34;); break; case FRIDAY: System.out.println(\u0026#34;FRIDAY\u0026#34;); break; case SATURDAY: System.out.println(\u0026#34;SATURDAY\u0026#34;); break; case SUNDAY: System.out.println(\u0026#34;SUNDAY\u0026#34;); break; default: break; } } } 1 2 3 4 class uskg.kotoriforest.enumtest.Week class java.lang.Enum java.lang.Enum MONDAY 开发中，当需要定义一组常量时，强烈建议使用枚举类。\nenum中的常用方法 既然enum继承自Enum，那么肯定会得到一些方法\n1 2 3 4 5 String toString(); // 默认返回的是常量名（对象名），可以继续手动重写该方法！ static 枚举类型[] values(); //返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法 static 枚举类型 valueOf(String name); // 可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”(即定义枚举类对象时写下的字面值，如 SPRING 的名字就是 SPRING)。如不是，会有运行时异常：IllegalArgumentException。 String name() // 得到当前枚举常量的名称。建议优先使用toString()。 int ordinal() // 返回当前枚举常量的次序号，默认从0开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.Scanner; public enum Week { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; } class TestEnumMethod { public static void main(String[] args) { //values() Week[] values = Week.values(); for (Week value : values) { //ordinal()、name() System.out.println((value.ordinal() + 1) + \u0026#34;-\u0026gt;\u0026#34; + value.name()); } System.out.println(\u0026#34;------------------------\u0026#34;); Scanner input = new Scanner(System.in); System.out.print(\u0026#34;请输入星期值：\u0026#34;); int weekValue = input.nextInt(); Week week = values[weekValue - 1]; //toString() System.out.println(week); System.out.print(\u0026#34;请输入星期名：\u0026#34;); String weekName = input.next(); //valueOf() week = Week.valueOf(weekName); System.out.println(week); input.close(); } } 1 2 3 4 5 6 7 8 9 10 11 12 1-\u0026gt;MONDAY 2-\u0026gt;TUESDAY 3-\u0026gt;WEDNESDAY 4-\u0026gt;THURSDAY 5-\u0026gt;FRIDAY 6-\u0026gt;SATURDAY 7-\u0026gt;SUNDAY ------------------------ 请输入星期值：3 WEDNESDAY 请输入星期名：SUNDAY SUNDAY 实现接口的枚举类 和普通 Java 类一样，枚举类可以实现一个或多个接口。 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要在枚举类中统一实现该方法即可。 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 枚举类可以像普通的类一样，实现接口，并且可以多个，但要求必须实现里面所有的抽象方法！ enum A implements 接口1，接口2 { //抽象方法的实现 } // 枚举类的实例可以独立重写抽象方法! enum A implements 接口1，接口2 { 常量名1(参数) { //抽象方法的实现或重写 }, 常量名2(参数) { //抽象方法的实现或重写 }, //... } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 interface Info { void show(); } //使用 enum 关键字定义枚举类 public enum Season implements Info { // 创建枚举类中的对象,声明在 enum 枚举类的首位 SPRING(\u0026#34;春天\u0026#34;, \u0026#34;春暖花开\u0026#34;) { public void show() { System.out.println(\u0026#34;春天在哪里？\u0026#34;); } }, SUMMER(\u0026#34;夏天\u0026#34;, \u0026#34;夏日炎炎\u0026#34;) { public void show() { System.out.println(\u0026#34;宁静的夏天\u0026#34;); } }, AUTUMN(\u0026#34;秋天\u0026#34;, \u0026#34;秋高气爽\u0026#34;), WINTER(\u0026#34;冬天\u0026#34;, \u0026#34;白雪皑皑\u0026#34;) { public void show() { System.out.println(\u0026#34;2002 年的第一场雪\u0026#34;); } }; // 声明每个对象拥有的属性 用 private final 修饰 private final String SEASON_NAME; private final String SEASON_DESC; // 私有化类的构造器 private Season(String seasonName, String seasonDesc) { this.SEASON_NAME = seasonName; this.SEASON_DESC = seasonDesc; } public String getSEASON_NAME() { return SEASON_NAME; } public String getSEASON_DESC() { return SEASON_DESC; } // 为枚举类实现抽象方法 // 如果每个枚举对象都实现了独属于自己的抽象方法 就可以不为抽象类实现 否则就要实现 这里 AUTUMN 没有实现自己的抽象方法 // 所以 AUTUMN 就会调用枚举类实现的方法 即这个方法 @Override public void show() { System.out.println(\u0026#34;这是一个平凡的季节\u0026#34;); } } class SeasonTest { public static void main(String[] args) { for (Season season : Season.values()) { season.show(); } } } 使用枚举来实现单例模式 1 2 3 4 5 6 7 8 9 10 11 // jdk5.0 之前使用枚举类定义单例模式 public class Singleton { public static final Singleton INSTANCE = new Singleton(); private Singleton() {} } // jdk5.0 及之后使用枚举类定义单例模式 public enum Singleton { instance; // public static final /* enum 默认的构造函数就是 private 的 所以不需要自己声明 */ } 注解 概述 注解（Annotation）是从 JDK5.0 开始引入，以“@注解名”在代码中存在。例如：\n@Override @Deprecated @SuppressWarnings( value=\u0026quot; \u0026quot; ) Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “key=value” 键值对中。\n注解可以在类编译、运行时进行加载，体现不同的功能。\n注解与注释的区别 注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解不同于单行注释和多行注释\n单行注释和多行注释是给程序员看的。 注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。 注解的重要性 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。但是在 JavaEE 和 Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。注解是一种趋势，一定程度上可以说：框架 = 注解 \u0026#43; 反射 \u0026#43; 设计模式。\n常见注解的作用 生成文档相关的注解 1 2 3 4 5 6 7 @author 标明开发该类模块的作者，多个作者之间使用\u0026#39;,\u0026#39;分割 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @since 从哪个版本开始增加的 @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是 void 就不能写 @exception 对方法可能抛出的异常进行说明，如果方法没有用 throws 显式抛出的异常就不能写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class JavadocTest { /** * 程序的主方法，程序的入口 * @param args String[] 命令行参数 */ public static void main(String[] args) {} /** * 求圆面积的方法 * @param radius double 半径值 * @return double 圆的面积 */ public static double getArea(double radius){ return Math.PI * radius * radius; } } 在编译时进行格式检查 ( JDK 内置的三个基本注解) 1 2 3 @Override: 限定于重写父类方法，该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class AnnotationTest { public static void main(String[] args) { @SuppressWarnings(\u0026#34;unused\u0026#34;) int a = 10; } @Deprecated(since = \u0026#34;8\u0026#34;) public void print() { System.out.println(\u0026#34;过时的方法\u0026#34;); } @Override public String toString() { return \u0026#34;重写的toString()\u0026#34;; } } 跟踪代码依赖性，实现替代配置文件功能 Servlet3.0 提供了注解（annotation），使得不再需要在 web.xml 文件中进行 Servlet 的部署。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 使用注解完成相关功能 @WebServlet(\u0026#34;/login\u0026#34;) public class LoginServlet extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) { } protected void doPost(HttpServletRequest request, HttpServletResp onse response) { doGet(request, response); } } // Spring 框架中关于“事务”的管理 @Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3) public void buyBook(String username, String isbn) { // 查询书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); // 更新库存 bookShopDao.updateBookStock(isbn); // 更新用户的余额 bookShopDao.updateUserAccount(username, price); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 使用配置文件完成相关功能 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;LoginServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.servlet.LoginServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;LoginServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/login\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!-- 配置事务属性 --\u0026gt; \u0026lt;tx:advice transaction-manager=\u0026#34;dataSourceTransactionManager\u0026#34; id=\u0026#34;tx Advice\u0026#34;\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!-- 配置每个方法使用的事务属性 --\u0026gt; \u0026lt;tx:methodname=\u0026#34;buyBook\u0026#34;propagation=\u0026#34;REQUIRES_NEW\u0026#34;isolation=\u0026#34;READ_COMMITTED\u0026#34; readonly=\u0026#34;false\u0026#34;timeout=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; 三个最基本的注解 @Override 用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！ 只能标记在方法上。 它会被编译器程序读取。 @Override 主要就是用来检查是否重写了父类或接口的的某个方法。你可能会感到困惑，正常人谁会写错啊，有必要特地写一个注解来检查吗？您还真别说，真不一定写的对。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class SuperClass { public void showMe1Message() { System.out.println(\u0026#34;SuperClass.showMe1Message\u0026#34;); } } public class AnnotationTest extends SuperClass { // 这里乍看过去好像是重写了父类的方法 但是其实并没有 // 在父类中是 \u0026#39;1\u0026#39; 而在子类中是 \u0026#39;l\u0026#39; public void showMelMessage() { System.out.println(\u0026#34;AnnotationTest.showMelMessage\u0026#34;); } } 如果你成功发现了这些细微差别，那么恭喜你，你的眼睛比我好多了，因为我真的有时候看快了就没看出来。没看出来也不要紧，因为@Override就是来解决这个问题的。\n如果你没有成功重写父类的方法的话，@Override就会报错，我还不信这么刺眼的红线你都看不见。\n但说实话，如果你用的是 IDEA ，Alt + Insrrt就能解决这个问题了，IDEA真是太方便了！\n@Deprecated 用于表示被标记的数据已经过时，不推荐使用。 可以用于修饰属性、方法、构造、类、包、局部变量、参数。 它会被编译器程序读取。 说实话这个注解就目前来说，我根本就用不到，也就是在 JDK 的官方库中才有机会见到。\n注解中的 since 标明从 jdk 的哪个版本开始废弃，forRemoval标识被注解的函数等会不会在将来被删除，所以如果一个函数、类……被标记为Deprecated就最好不要在程序中使用了。如果你使用了，编译器可能会给你报错误或者警告，但是不要紧，还是可以正常编译运行的。\n@SuppressWarnings 抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息。 可以用于修饰类、属性、方法、构造、局部变量、参数。 它会被编译器程序读取。 可以指定的警告类型有（部分）： 警告类型 说明 all 抑制所有警告 unchecked 抑制与未检查的作业相关的警告 unused 抑制与未用的程式码及停用的程式码相关的警告 deprecation 抑制与淘汰的相关警告 nls 抑制与非 nls 字串文字相关的警告 null 抑制与空值分析相关的警告 rawtypes 抑制与使用 raw 类型相关的警告 static access 抑制与静态存取不正确相关的警告 static method 抑制与可能宣告为 static 的方法相关的警告 super 抑制与置换方法相关但不含 super 呼叫的警告 元注解 元注解简而言之来说就是作用于注解的注解。\nJDK1.5 在 java.lang.annotation 包定义了4个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。\n@Target：用于描述注解的使用范围 可以通过枚举类型 ElementType 的 10 个常量对象来指定 @Retention：用于描述注解的生命周期 可以通过枚举类型 RetentionPolicy 的 3 个常量对象来指定，分别是SOURCE （源代码）、 CLASS （字节码）、 RUNTIME （运行时） 唯有 RUNTIME 阶段才能被反射读取到。 @Documented：表明这个注解应该被 javadoc工具记录。 @Inherited：允许子类继承父类中的注解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public enum ElementType { /** Class, interface (including annotation interface), enum, or record * declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation interface declaration (Formerly known as an annotation type.) */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE, /** * Module declaration. * * @since 9 */ MODULE, /** * Record component * * @jls 8.10.3 Record Members * @jls 9.7.4 Where Annotations May Appear * * @since 16 */ RECORD_COMPONENT; } 1 2 3 4 5 6 7 8 9 10 11 12 13 // @Deprecated 的定义 package java.lang; import java.lang.annotation.*; import static java.lang.annotation.ElementType.*; @Documented @Retention(RetentionPolicy.RUNTIME) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE}) public @interface Deprecated { String since() default \u0026#34;\u0026#34;; boolean forRemoval() default false; } 自定义注解的使用 一个完整的注解应该包含三个部分：（1）声明 （2）使用 （3）读取\n1 2 3 4 [元注解] [修饰符] @interface \u0026lt;注解名\u0026gt; { [成员列表] } 自定义注解可以通过四个元注解 @Retention, @Target, @Inherited, @Documented 分别说明它的声明周期，使用位置，是否被继承，是否被生成到 API 文档中。\nAnnotation 的成员在 Annotation 的定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型：String 类型、 Class 类型、 enum 类型、 Annotation 类型、以上所有类型的数组。可以使用 default 关键字为抽象方法指定默认返回值。\n如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是 “方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为 value，则可以省略 “ value= ”，所以如果注解只有一个抽象方法成员，建议使用方法名 value 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; // 定义自定义注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation { // 定义带有默认值的属性 String name() default \u0026#34;DefaultName\u0026#34;; // 如果没有指定，使用默认值 int age() default 18; // 如果没有指定，使用默认值 String[] tags() default {\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;}; // 数组类型默认值 } // 使用了默认值 @MyAnnotation class Example1 { } // 这里覆盖了默认值 @MyAnnotation(name = \u0026#34;John\u0026#34;, age = 25, tags = {\u0026#34;developer\u0026#34;, \u0026#34;java\u0026#34;}) class Example2 { } 自定义注解必须配上注解的信息处理流程才有意义。我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。\n反射我还没学到，等之后再说，嘿嘿🤭\n","date":"2024-10-16T00:48:39+08:00","image":"https://kotoriforest.us.kg/p/1016-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/cover_hu7516527291003337567.png","permalink":"https://kotoriforest.us.kg/p/1016-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/","title":"简单介绍枚举和注解"},{"content":"概述 ​\t接口就是规范，定义的是一组规则，体现了现实世界中”如果你是 / 要\u0026hellip;则必须能\u0026hellip;”的思想。继承是一个\u0026quot;是不是\u0026quot;的 is-a 关系，而接口实现则是 \u0026ldquo;能不能\u0026quot;的 has-a 关系。\n​\t例如：Java 程序是否能够连接使用某种数据库产品，那么要看该数据库产品能否实现 Java 设计的 JDBC 规范\n​\t接口的本质是契约、标准、规范，就像我们的法律一样。制定好后大家都要遵守。\n接口 接口的定义 ​\t接口的定义与类的定义方式相似，只是将 class 关键字换成了 interface 关键字。它同样也会被编译成 .class 文件，但一定要明确它并不是类，而是另外一种引用数据类型。\n1 2 3 4 5 6 7 8 9 10 package uskg.kotoriforest.api; public interface Interface { } class Test1 implements Interface { public static void main(String[] args) { } } 在 interface 内部，我们可以声明属性和方法。其中属性必须使用 public static final 修饰，但其实interface中的属性默认就是 public static final 的，所以可以不写😓；而方法则需要声明为 public abstract，同样的，因为接口中的方法的默认修饰就为 public abstract，所以也可以不写。\n​\t上述是 jdk8 之前的规范，在 jdk8 及以后，接口内可以声明静态方法和默认方法。在 jdk9 及以后，接口内还可以声明私有方法。但我们主要还是使用 public abstract 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public interface Interface { public static final int SIZE = 100; // int SIZE = 100; 这样也是可以的 public abstract void method(); // void method(); OK！ // 默认方法 其中 public 可以省略 但建议保留 public default void method2() { System.out.println(\u0026#34;method2\u0026#34;); } // 静态方法 其中 public 可以省略 但建议保留 public static void method3() { System.out.println(\u0026#34;method3\u0026#34;); } // 静态方法 可以用 static 修饰 // 如果是非 static 就是给接口内部的默认方法调用的 // 如果是 static 就是给接口内部的默认方法和静态方法调用的 private void method4() { System.out.println(\u0026#34;method4\u0026#34;); } // public 可以省略 // 接口也能像类一样 拥有自己的内部接口😋 public interface Inner { } } ​\t说完可以在接口内声明的，还需要提一嘴不能在接口内声明的，构造器、代码块都是不能出现于接口内部的，因为接口并不能被实例化，且接口中没有成员变量需要动态初始化。\n1 2 3 4 5 public interface Interface { Interface() {} // error {} // error static {} // error } 接口的使用 类实现接口 ​\t接口不能创建对象，但是可以被类实现。类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。\n1 2 3 4 5 6 7 8 9 [修饰符] class [class name] implements [interface name] { // [必须] 实现接口中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } [修饰符] class [class name] extends [super class name] implements [interface name] { // [必须] 实现接口中的抽象方法 如果父类也是抽象类也需要实现父类中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } 如果接口的实现类是非抽象类，那么必须重写接口中所有抽象方法。\n默认方法可以选择保留原实现，也可以重写。\n重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了。\n接口中的静态方法和私有方法不能被继承也不能被重写。\n接口的多实现 ​\t在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的多实现。所以，一个类能继承一个父类，同时实现多个接口。\n1 2 3 4 5 6 7 8 9 [修饰符] class [class name] implements [interface name1], [interface name2], [interface name3]... { // [必须] 实现接口中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } [修饰符] class [class name] extends [super class name] [interface name1], [interface name2], [interface name3]... { // [必须] 实现接口中的抽象方法 如果父类也是抽象类也需要实现父类中的抽象方法 但如果本类是抽象类的话 就可以不实现 // [可选] 重写接口中的默认方法 } ​\t接口中有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public interface Interface { void method1(); void method2(); } interface Api { void method1(); void method3(); } class Test implements Interface, Api{ @Override public void method1() { // 同时重写了 Interface 和 Api 中的 method1 System.out.println(\u0026#34;method1\u0026#34;); } @Override public void method3() { System.out.println(\u0026#34;method2\u0026#34;); } @Override public void method2() { System.out.println(\u0026#34;method3\u0026#34;); } } ​\t类针对于接口的多实现，在一定程度上弥补了单继承的局限性（只能拿到声明，不能拿到实现）。\n接口的多继承 ​\t一个接口能继承另一个或者多个接口，接口的继承也使用 extends 关键字，子接口会继承父接口的方法。\n​\t一个子类只能有一个父类，但谁说一个子接口只能有一个父接口了😎。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public interface Interface { void method1(); default void method2(){} } interface Api { static void method3() {} private static void method4() {} } interface Outer extends Interface, Api { default void method5() { method1(); method2(); Api.method3(); // 子接口不能继承父接口的 static 和 private 方法 } } class Test implements Outer { @Override public void method1() { } @Override public void method2() { Outer.super.method2(); } @Override public void method5() { Outer.super.method5(); } } 接口与实现类对象构成多态引用 ​\t实现类实现接口，类似于子类继承父类，因此，接口类型的变量与实现类的对象之间，也可以构成多态引用。通过接口类型的变量调用方法，最终执行的是你 new 的实现类对象实现的方法体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public interface IOut { void goOut(); } class TheRich implements IOut { public void goOut() { System.out.println(\u0026#34;坐飞机头等舱\u0026#34;); } } class ThePoor implements IOut { public void goOut() { System.out.println(\u0026#34;坐快车硬座\u0026#34;); } } class Test { public static void main(String[] args) { IOut theRich = new TheRich(); theRich.goOut(); System.out.println(\u0026#34;--------------------\u0026#34;); IOut thePoor = new ThePoor(); thePoor.goOut(); } } 1 2 3 坐飞机头等舱 -------------------- 坐快车硬座 接口在 jdk8 和 jdk9 中的新特性 使用接口的静态成员 ​\t接口不能直接创建对象，但是可以通过接口名直接调用接口的静态方法和静态常量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Interface { int NUMBER = 0X1234; static void method(){ System.out.println(\u0026#34;method\u0026#34;); }; } class Test implements Interface{ public static void main(String[] args) { System.out.println(Interface.NUMBER); // OK System.out.println(Test.NUMBER); // OK Interface.method(); // OK Test.method(); // error: static 方法通过其的定义接口调用 不能通过实现类调用 } } 在 Java 中，接口不能继承父接口的 static 方法。这是因为 static 方法属于接口本身，而不是它的实现类或子接口。\nstatic 方法在 Java 接口中只能通过接口名直接调用，不能通过实现类或子接口进行调用。 子接口或实现类不会继承父接口的 static 方法。 这是 Java 的设计决定：static 方法属于定义它的接口，不能通过继承传播。 回忆一下 Java 中的继承对 static 方法的处理方式：\n在 Java 中，子类不能继承父类的 static 方法，但子类可以通过类名直接调用父类的 static 方法。这是因为 static 方法是属于类本身的，而不是属于某个实例或子类。\nstatic 方法属于类，而不是对象：static 方法在类加载时就存在，属于类本身，不依赖于类的实例。 不能通过继承来重写 static 方法：子类不会真正“继承”父类的 static 方法，而是拥有它自己的 static 方法空间。如果子类定义了一个相同名字的 static 方法，这种行为被称为“隐藏”而不是“重写”。 调用方式：static 方法应通过类名调用，即使子类定义了相同的方法，也只能通过类名调用，不应通过实例调用。 使用接口的默认方法 对于接口的静态方法，直接使用接口名进行调用即可，也只能使用接口名进行调用，不能通过实现类的对象进行调用。 对于接口的抽象方法、默认方法，只能通过实现类对象才可以调用，接口不能直接创建对象，只能创建实现类的对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface Interface { // default 可以看作是用来顶替 abstract 的位置的 // 如果什么也不写会默认是 abstract 而 default 就是为了声明该函数不是抽象函数，具有函数体 public default void method1() { System.out.println(\u0026#34;method1\u0026#34;); } default void method2() { System.out.println(\u0026#34;method2\u0026#34;); } default void method3() { // default 函数可以调用其他的default、static、private、private static 方法 method1(); method2(); System.out.println(\u0026#34;method3\u0026#34;); } } class Test implements Interface { @Override public void method1() { // Interface.super.method1(); System.out.println(\u0026#34;Test::method1\u0026#34;); } public static void main(String[] args) { Test test = new Test(); test.method3(); } } 1 2 3 Test::method1 method2 method3 ​\t接口中声明的默认方法可以被实现类继承，实现类在没有重写此方法的情况下，默认调用接口中声明的默认方法。如果实现类重写了此方法，则调用的是自己重写的方法。\n使用接口的私有方法 ​\t接口的私有方法非常简单，你可以简单的认为它是私有的默认方法，但是不能使用 default 关键字。\n1 2 3 4 interface Interface { // 可以带上 static private void method() {} } ​\t私有方法的主要作用就是将静态方法和默认方法中重复出现的代码提取出来，然后进行复用。\njdk8 中相关冲突问题 默认方法冲突 接口冲突 当一个类同时实现了多个父接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？\n无论你多难抉择，最终都是要做出选择的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Interface { default void method() { System.out.println(\u0026#34;Interface method\u0026#34;); } } interface Api { default void method() { System.out.println(\u0026#34;Api method\u0026#34;); } } class Test implements Interface, Api { // error: Test 从类型 Interface 和 Api 继承 method() 的不相关默认值 } ​\t类实现了两个接口，而两个接口定义了同名同参数（相同签名）的默认方法。则实现类在没有重写这两个接口默认方法的条件下，会报错。我们把这个叫做接口冲突。（如果是抽象方法就不会有这个问题，因为抽象方法一定要重写😋）\n1 2 3 4 5 6 7 8 9 10 11 class Test implements Interface, Api { @Override public void method() { // 解决方案1: 保留其中一个父接口的实现 下面二选一 // Interface.super.method(); // Api.super.method(); // 解决方案2: 完全重写 System.out.println(\u0026#34;Test method\u0026#34;); } } ​\t当一个子接口同时继承了多个接口，而多个父接口中包含方法签名相同的默认方法时，怎么办呢？\n​\t当然也是需要重写的了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface Interface { default void method() { System.out.println(\u0026#34;Interface method\u0026#34;); } } interface Api { default void method() { System.out.println(\u0026#34;Api method\u0026#34;); } } interface IProgram extends Interface, Api { @Override default void method() { // Interface.super.method(); // Api.super.method(); System.out.println(\u0026#34;IProgram method\u0026#34;); } } 子接口重写默认方法时，default 关键字必须保留。\n子类重写默认方法时，default 关键字不可以保留。\n类优先原则 ​\t子类（或实现类）继承了父类并实现了接口，并且父类和接口中声明了签名相同的方法。默认的，子类（或实现类）在没有重写此方法的情况下，调用的是父类中的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public interface Interface { default void method1() { System.out.println(\u0026#34;Interface method1\u0026#34;); } void method2(); } class SuperClass { public void method1() { System.out.println(\u0026#34;SuperClass method1\u0026#34;); } public void method2() { System.out.println(\u0026#34;SuperClass method2\u0026#34;); } } class SubClass extends SuperClass implements Interface { public static void main(String[] args) { SubClass subClass = new SubClass(); subClass.method1(); subClass.method2(); System.out.println(\u0026#34;-----------------------------\u0026#34;); new SubClass() { @Override public void method1() { System.out.println(\u0026#34;SubClass method1\u0026#34;); } }.method1(); } } 1 2 3 4 SuperClass method1 SuperClass method2 ----------------------------- SubClass method1 ​\t如果现在我们有一个实现类重写了父类和接口中的签名相同的方法，那么我们如何分别调用实现类自己的、父类的、父接口中的签名相同的方法呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class SubClass extends SuperClass implements Interface { @Override public void method1() { System.out.println(\u0026#34;SubClass method1\u0026#34;); } public void exec() { method1(); // 调用自己的 super.method1(); // 调用父类的 Interface.super.method1(); // 调用父接口的 } public static void main(String[] args) { new SubClass().exec(); } } 1 2 3 SubClass method1 SuperClass method1 Interface method1 常量冲突问题 问题出现的原因：\n当子类既继承父类又实现父接口，而父类中存在与父接口常量同名的成员变量，并且该成员变量名在子类中仍然可见。 子类同时实现多个接口，而多个接口存在相同同名常量。 ​\t上述条件只要满足其一，在子类中想要引用父类或父接口的同名的常量或成员变量时，就会有冲突。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class SuperClass { int x = 1;} interface SuperInterface { int x = 2; int y = 2; } interface MotherInterface { int x = 3; } class SubClass extends SuperClass implements SuperInterface, MotherInterface { public void method(){ // System.out.println(\u0026#34;x = \u0026#34; + x);//模糊不清 System.out.println(\u0026#34;super.x = \u0026#34; + super.x); System.out.println(\u0026#34;SuperInterface.x = \u0026#34; + SuperInterface.x); System.out.println(\u0026#34;MotherInterface.x = \u0026#34; + MotherInterface.x); System.out.println(\u0026#34;y = \u0026#34; + y);//没有重名问题，可以直接访问 } public static void main(String[] args) { new SubClass().method(); } } 1 2 3 4 super.x = 1 SuperInterface.x = 2 MotherInterface.x = 3 y = 2 接口的总结与面试题 总结 接口本身不能创建对象，只能创建接口的实现类对象，接口类型的变量可以与实现类对象构成多态引用。\n声明接口用 interface ，接口的成员声明有限制：\n① 公共的静态常量\n② 公共的抽象方法\n③ 公共的默认方法 （ JDK8.0 及以上）\n④ 公共的静态方法 （ JDK8.0 及以上）\n⑤ 私有方法 （ JDK9.0 及以上）\n类可以实现接口，关键字是 implements ，并且支持多实现。如果实现类不是抽象类就必须实现接口中所有的抽象方法。如果实现类既要继承父类又要实现父接口，那么继承（ extends ）在前，实现 （ implements ）在后。\n接口可以继承接口，关键字是 extends ，而且支持多继承。\n接口的默认方法可以选择重写或不重写。如果有冲突问题就需要另行处理。子类重写父接口的默认方法，要去掉 default ，子接口重写父接口的默认方法，不要去掉 default。\n接口的静态方法不能被继承，也不能被重写。接口的静态方法只能通过 “ 接口名.静态方法名 ” 进行调用。\n面试题 为什么接口中只能声明公共的静态的常量？\n因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。\n为什么 JDK 8.0 之后允许接口定义静态方法和默认方法呢？它违反了接口作为一个抽象标准定义的概念。\n静态方法：因为之前的标准类库设计中，有很多 Collection / Colletions 或者 Path / Paths 这样成对的接口和类，后面的类中是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对 API，不如把静态方法直接定义到接口中使用和维护更方便。 默认方法：（1）我们要在已有的老版接口中提供新方法时，如果添加抽象方法，就会涉及到原来使用这些接口的类就会有题，那么为了保持与旧版本代码的兼容性，只能允许在接口中定义默认方法实现。比如：Java8 中对 Collection、List、Comparator等接口提供了丰富的默认方法。（2）当我们接口的某个抽象方法，在很多实现类中的实现代码是一样的，此时将这个抽象方法设计为默认方法更为合适，那么实现类就可以选择重写，也可以选择不重写。 为什么JDK1.9 要允许接口定义私有方法呢？我们说接口是规范，规范是需要公开让大家遵守的。\n因为有了默认方法和静态方法这样具有具体实现的方法，那么就可能出现多个方法由共同的代码可以抽取，而这些共同的代码抽取出来的方法又只希望在接口内部使用，所以就增加了私有方法。\n接口与抽象类之间的对比 ","date":"2024-10-14T21:50:33+08:00","image":"https://kotoriforest.us.kg/p/1014-%E6%8E%A5%E5%8F%A3interface/cover_hu10474594242259417286.png","permalink":"https://kotoriforest.us.kg/p/1014-%E6%8E%A5%E5%8F%A3interface/","title":"接口interface"}]